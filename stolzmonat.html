<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Profile Image Generator â€” Tinted / Ring Clip</title>
<style>
  :root{ --preview-size:300px; }
  body{
    font-family: system-ui, sans-serif;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:12px;
    margin:24px;
  }
  canvas{ display:none; }
  #preview{
    width:var(--preview-size);
    height:var(--preview-size);
    border-radius:50%;
    object-fit:cover;
    background:#f0f0f0;
    touch-action:none;
    user-select:none;
    -webkit-user-select:none;
    -webkit-tap-highlight-color:transparent;
    box-shadow: 0 6px 18px rgba(0,0,0,0.12);
  }
  .controls{ display:flex; flex-direction:column; gap:8px; align-items:center; }
  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:center; }
  input[type="range"]{ width:var(--preview-size); }
  button{
    padding:8px 14px;
    font-size:15px;
    border-radius:6px;
    border:1px solid rgba(0,0,0,0.08);
    background:#fff;
    cursor:pointer;
  }
  label{ font-size:13px; color:#333; }
</style>
</head>
<body>

<h3>Profile Image Generator</h3>

<input id="upload" type="file" accept="image/*">
<img id="preview" alt="Profile preview">

<div class="controls">

  <!-- Mode selector -->
  <div class="row">
    <label><input type="radio" name="mode" value="tint" checked> Tinted</label>
    <label><input type="radio" name="mode" value="ring"> Ring Clip</label>
  </div>

  <!-- Border slider (only relevant in Ring mode) -->
  <div class="row">
    <label for="borderWidthSlider">Border Thickness</label>
  </div>
  <input id="borderWidthSlider" type="range" min="0.5" max="2" step="0.01" value="1.3">

  <!-- Tint opacity slider -->
  <div class="row">
    <label for="tintOpacity">Tint opacity</label>
    <input id="tintOpacity" type="range" min="0" max="1" step="0.01" value="0.4">
  </div>

  <!-- Buttons -->
  <div class="row">
    <button id="downloadBtn">Download Image</button>
    <button id="resetBtn">Reset Position</button>
  </div>
</div>

<canvas id="canvas" width="1000" height="1000"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const preview = document.getElementById('preview');
const upload = document.getElementById('upload');
const borderWidthSlider = document.getElementById('borderWidthSlider');
const tintOpacityInput = document.getElementById('tintOpacity');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');
const modeRadios = document.querySelectorAll('input[name="mode"]');

const CANVAS_SIZE = canvas.width;
const BASE_OUTER = 480;
const BASE_THICKNESS = 80;

const COLOR_BLACK = '#000000';
const COLOR_RED   = '#ff0000';
const COLOR_GOLD  = '#ffd700';

let uploadedImg = null;
let imgScale = 1.0;
let offsetX = 0;
let offsetY = 0;

let borderScale = parseFloat(borderWidthSlider.value);
let tintOpacity = parseFloat(tintOpacityInput.value);
let mode = "tint";

// --- Helpers ---
function hexToRgb(hex){
  hex = hex.replace('#','');
  if (hex.length === 3) hex = hex.split('').map(h=>h+h).join('');
  const n = parseInt(hex,16);
  return [(n>>16)&255,(n>>8)&255,n&255];
}
function rgbToHex([r,g,b]){
  return "#" + r.toString(16).padStart(2,'0') +
               g.toString(16).padStart(2,'0') +
               b.toString(16).padStart(2,'0');
}
function lerp(a,b,t){ return a + (b-a)*t; }
function lerpColorHex(aHex,bHex,t){
  const a = hexToRgb(aHex), b = hexToRgb(bHex);
  return rgbToHex([Math.round(lerp(a[0],b[0],t)),
                   Math.round(lerp(a[1],b[1],t)),
                   Math.round(lerp(a[2],b[2],t))]);
}
function build7Colors(){
  const colors = [];
  const stepsBR = [0, 1/3, 2/3, 1];
  for (let t of stepsBR) colors.push(lerpColorHex(COLOR_BLACK, COLOR_RED, t));
  const stepsRG = [1/3, 2/3, 1].map(t => lerpColorHex(COLOR_RED, COLOR_GOLD, t));
  colors.push(...stepsRG);
  return colors;
}

// --- Drawing ---
function drawCanvas(){
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);

  let effectiveScale = (mode === "ring") ? borderScale : 0;
  const innerR = Math.max(10, Math.round(BASE_OUTER - (BASE_THICKNESS * effectiveScale)));

  // --- Draw photo clipped to inner circle ---
  ctx.save();
  ctx.beginPath();
  ctx.arc(CANVAS_SIZE/2, CANVAS_SIZE/2, innerR, 0, Math.PI*2);
  ctx.closePath();
  ctx.clip();

  if (uploadedImg){
    const baseSize = Math.min(uploadedImg.width, uploadedImg.height);
    const drawSize = baseSize * imgScale;
    const sx = (uploadedImg.width - baseSize)/2;
    const sy = (uploadedImg.height - baseSize)/2;
    ctx.drawImage(uploadedImg, sx, sy, baseSize, baseSize,
      (CANVAS_SIZE - drawSize)/2 + offsetX,
      (CANVAS_SIZE - drawSize)/2 + offsetY,
      drawSize, drawSize);
  } else {
    ctx.fillStyle = '#ccc';
    ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
  }

  if (mode === "tint"){
    const colors = build7Colors();
    const bandHeight = (innerR*2) / colors.length;
    ctx.globalAlpha = tintOpacity;
    for (let i=0; i<colors.length; i++){
      ctx.fillStyle = colors[i];
      ctx.fillRect(CANVAS_SIZE/2 - innerR, CANVAS_SIZE/2 - innerR + i*bandHeight, innerR*2, bandHeight);
    }
    ctx.globalAlpha = 1.0;
  }
  ctx.restore();

  // --- Draw ring (only in ring mode) ---
  if (mode === "ring"){
    const colors = build7Colors();
    const outerR = BASE_OUTER;
    const bandHeight = (outerR*2) / colors.length;

    ctx.save();
    ctx.beginPath();
    ctx.arc(CANVAS_SIZE/2, CANVAS_SIZE/2, outerR, 0, Math.PI*2);
    ctx.arc(CANVAS_SIZE/2, CANVAS_SIZE/2, innerR, 0, Math.PI*2, true);
    ctx.closePath();
    ctx.clip();

    ctx.globalAlpha = tintOpacity;
    for (let i=0; i<colors.length; i++){
      ctx.fillStyle = colors[i];
      ctx.fillRect(CANVAS_SIZE/2 - outerR, CANVAS_SIZE/2 - outerR + i*bandHeight, outerR*2, bandHeight);
    }
    ctx.globalAlpha = 1.0;
    ctx.restore();
  }

  preview.src = canvas.toDataURL('image/png');
}

// --- Events ---
upload.addEventListener('change', e=>{
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = ()=>{ uploadedImg = img; imgScale=1; offsetX=0; offsetY=0; drawCanvas(); };
  img.src = URL.createObjectURL(file);
});
borderWidthSlider.addEventListener('input', e=>{ borderScale=parseFloat(e.target.value); drawCanvas(); });
tintOpacityInput.addEventListener('input', e=>{ tintOpacity=parseFloat(e.target.value); drawCanvas(); });
modeRadios.forEach(r=> r.addEventListener('change', e=>{ mode=e.target.value; drawCanvas(); }));
downloadBtn.addEventListener('click', ()=>{
  const a=document.createElement('a');
  a.download='profile-image.png';
  a.href=canvas.toDataURL('image/png');
  a.click();
});
resetBtn.addEventListener('click', ()=>{ offsetX=0; offsetY=0; imgScale=1; drawCanvas(); });

drawCanvas();
</script>
</body>
</html>