<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Profile Image Generator — Tinted / Ring Clip</title>
<style>
  :root{ --preview-size:300px; }
  body{
    font-family: system-ui, sans-serif;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:12px;
    margin:24px;
  }
  canvas{ display:none; }
  #preview{
    width:var(--preview-size);
    height:var(--preview-size);
    border-radius:50%;
    object-fit:cover;
    background:#f0f0f0;
    touch-action:none;
    user-select:none;
    -webkit-user-select:none;
    -webkit-tap-highlight-color:transparent;
    box-shadow: 0 6px 18px rgba(0,0,0,0.12);
    cursor: grab;
  }
  .controls{ display:flex; flex-direction:column; gap:8px; align-items:center; }
  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:center; }
  input[type="range"]{ width:var(--preview-size); }
  button{
    padding:8px 14px;
    font-size:15px;
    border-radius:6px;
    border:1px solid rgba(0,0,0,0.08);
    background:#fff;
    cursor:pointer;
  }
  label{ font-size:13px; color:#333; }
</style>
</head>
<body>

<h3>Profile Image Generator</h3>

<input id="upload" type="file" accept="image/*">
<img id="preview" alt="Profile preview">

<div class="controls">
  <div class="row">
    <label><input type="radio" name="mode" value="tint" checked> Tinted</label>
    <label><input type="radio" name="mode" value="ring"> Ring Clip</label>
  </div>

  <div class="row">
    <label for="borderWidthSlider">Border Thickness</label>
  </div>
  <input id="borderWidthSlider" type="range" min="0.5" max="2" step="0.01" value="1.3">

  <div class="row">
    <label for="tintOpacity">Tint opacity</label>
    <input id="tintOpacity" type="range" min="0" max="1" step="0.01" value="0.4">
  </div>

  <div class="row">
    <button id="downloadBtn">Download Image</button>
    <button id="resetBtn">Reset Position</button>
  </div>
</div>

<canvas id="canvas" width="1000" height="1000"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const preview = document.getElementById('preview');
const upload = document.getElementById('upload');
const borderWidthSlider = document.getElementById('borderWidthSlider');
const tintOpacityInput = document.getElementById('tintOpacity');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');
const modeRadios = document.querySelectorAll('input[name="mode"]');

const CANVAS_SIZE = canvas.width;
const BASE_OUTER = 480;
const BASE_THICKNESS = 80;

const COLOR_BLACK = '#000000';
const COLOR_RED   = '#ff0000';
const COLOR_GOLD  = '#ffd700';

let uploadedImg = null;
let imgScale = 1.0;
let offsetX = 0;
let offsetY = 0;

let borderScale = parseFloat(borderWidthSlider.value);
let tintOpacity = parseFloat(tintOpacityInput.value);
let mode = "tint";

// --- Helpers ---
function hexToRgb(hex){
  hex = hex.replace('#','');
  if (hex.length === 3) hex = hex.split('').map(h=>h+h).join('');
  const n = parseInt(hex,16);
  return [(n>>16)&255,(n>>8)&255,n&255];
}
function rgbToHex([r,g,b]){
  return "#" + r.toString(16).padStart(2,'0') +
               g.toString(16).padStart(2,'0') +
               b.toString(16).padStart(2,'0');
}
function lerp(a,b,t){ return a + (b-a)*t; }
function lerpColorHex(aHex,bHex,t){
  const a = hexToRgb(aHex), b = hexToRgb(bHex);
  return rgbToHex([Math.round(lerp(a[0],b[0],t)),
                   Math.round(lerp(a[1],b[1],t)),
                   Math.round(lerp(a[2],b[2],t))]);
}
function build7Colors(){
  const colors = [];
  const stepsBR = [0, 1/3, 2/3, 1];
  for (let t of stepsBR) colors.push(lerpColorHex(COLOR_BLACK, COLOR_RED, t));
  const stepsRG = [1/3, 2/3, 1].map(t => lerpColorHex(COLOR_RED, COLOR_GOLD, t));
  colors.push(...stepsRG);
  return colors;
}

// --- Drawing ---
function drawCanvas(){
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);

  let effectiveScale = (mode === "ring") ? borderScale : 0;
  const innerR = Math.max(10, Math.round(BASE_OUTER - (BASE_THICKNESS * effectiveScale)));

  // --- Draw photo clipped to inner circle ---
  ctx.save();
  ctx.beginPath();
  ctx.arc(CANVAS_SIZE/2, CANVAS_SIZE/2, innerR, 0, Math.PI*2);
  ctx.closePath();
  ctx.clip();

  if (uploadedImg){
    const baseSize = Math.min(uploadedImg.width, uploadedImg.height);
    const drawSize = baseSize * imgScale;
    const sx = (uploadedImg.width - baseSize)/2;
    const sy = (uploadedImg.height - baseSize)/2;
    ctx.drawImage(uploadedImg, sx, sy, baseSize, baseSize,
      (CANVAS_SIZE - drawSize)/2 + offsetX,
      (CANVAS_SIZE - drawSize)/2 + offsetY,
      drawSize, drawSize);
  } else {
    ctx.fillStyle = '#ccc';
    ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
  }

  if (mode === "tint"){
    const colors = build7Colors();
    const bandHeight = (innerR*2) / colors.length;
    ctx.globalAlpha = tintOpacity;
    for (let i=0; i<colors.length; i++){
      ctx.fillStyle = colors[i];
      ctx.fillRect(CANVAS_SIZE/2 - innerR, CANVAS_SIZE/2 - innerR + i*bandHeight, innerR*2, bandHeight);
    }
    ctx.globalAlpha = 1.0;
  }
  ctx.restore();

  // --- Draw ring (only in ring mode) ---
  if (mode === "ring"){
    const colors = build7Colors();
    const outerR = BASE_OUTER;
    const bandHeight = (outerR*2) / colors.length;

    ctx.save();
    ctx.beginPath();
    ctx.arc(CANVAS_SIZE/2, CANVAS_SIZE/2, outerR, 0, Math.PI*2);
    ctx.arc(CANVAS_SIZE/2, CANVAS_SIZE/2, innerR, 0, Math.PI*2, true);
    ctx.closePath();
    ctx.clip();

    ctx.globalAlpha = tintOpacity;
    for (let i=0; i<colors.length; i++){
      ctx.fillStyle = colors[i];
      ctx.fillRect(CANVAS_SIZE/2 - outerR, CANVAS_SIZE/2 - outerR + i*bandHeight, outerR*2, bandHeight);
    }
    ctx.globalAlpha = 1.0;
    ctx.restore();
  }

  preview.src = canvas.toDataURL('image/png');
}

// --- Drag & Pinch ---
let dragging = false;
let lastX = 0, lastY = 0;
let lastDist = null;

preview.addEventListener('pointerdown', e=>{
  dragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
  preview.setPointerCapture(e.pointerId);
});
preview.addEventListener('pointermove', e=>{
  if (!dragging) return;
  if (e.pointerType === 'touch' || e.pointerType === 'pen' || e.pointerType === 'mouse'){
    if (e.pressure && e.pressure>0 && e.touches && e.touches.length === 2){
      // ignore here; handled in touchmove
      return;
    }
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    offsetX += dx;
    offsetY += dy;
    lastX = e.clientX;
    lastY = e.clientY;
    drawCanvas();
  }
});
preview.addEventListener('pointerup', e=>{
  dragging = false;
  lastDist = null;
  preview.releasePointerCapture(e.pointerId);
});
preview.addEventListener('wheel', e=>{
  e.preventDefault();
  imgScale *= e.deltaY<0 ? 1.05 : 0.95;
  drawCanvas();
});

// Touch pinch handling
let ongoingTouches = [];
preview.addEventListener('touchstart', e=>{
  if (e.touches.length === 2){
    const [t1, t2] = e.touches;
    lastDist = Math.hypot(t2.clientX-t1.clientX, t2.clientY-t1.clientY);
  }
});
preview.addEventListener('touchmove', e=>{
  if (e.touches.length === 2){
    e.preventDefault();
    const [t1, t2] = e.touches;
    const dist = Math.hypot(t2.clientX-t1.clientX, t2.clientY-t1.clientY);
    if (lastDist) {
      const scaleChange = dist / lastDist;
      imgScale *= scaleChange;
      lastDist = dist;
      drawCanvas();
    }
  } else if (e.touches.length === 1){
    const t = e.touches[0];
    const dx = t.clientX - lastX;
    const dy = t.clientY - lastY;
    offsetX += dx;
    offsetY += dy;
    lastX = t.clientX;
    lastY = t.clientY;
    drawCanvas();
  }
});
preview.addEventListener('touchend', e=>{
  if (e.touches.length < 2) lastDist = null;
});
preview.addEventListener('touchstart', e=>{
  if (e.touches.length === 1){
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  }
});

// --- Other Events ---
upload.addEventListener('change', e=>{
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = ()=>{ uploadedImg = img; imgScale=1; offsetX=0; offsetY=0; drawCanvas(); };
  img.src = URL.createObjectURL(file);
});
borderWidthSlider.addEventListener('input', e=>{ borderScale=parseFloat(e.target.value); drawCanvas(); });
tintOpacityInput.addEventListener('input', e=>{ tintOpacity=parseFloat(e.target.value); drawCanvas(); });
modeRadios.forEach(r=> r.addEventListener('change', e=>{ mode=e.target.value; drawCanvas(); }));
downloadBtn.addEventListener('click', ()=>{
  const a=document.createElement('a');
  a.download='profile-image.png';
  a.href=canvas.toDataURL('image/png');
  a.click();
});
resetBtn.addEventListener('click', ()=>{ offsetX=0; offsetY=0; imgScale=1; drawCanvas(); });

drawCanvas();
</script>

<!-- NAVIGATION INJECTED -->
<style>
  body { margin: 0; font-family: Arial, sans-serif; }
  header {
    background: #333; color: white; padding: 10px 20px;
    display: flex; justify-content: space-between; align-items: center;
    position: sticky; top: 0; z-index: 1000;
  }
  header a { color: white; text-decoration: none; font-weight: bold; }
  .menu-btn { background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; }
  .drawer {
    height: 100%; width: 250px; position: fixed; top: 0; left: -250px;
    background: #444; overflow-x: hidden; transition: 0.3s; padding-top: 60px;
    z-index: 999;
  }
  .drawer.open { left: 0; }
  .drawer a {
    padding: 10px 20px; text-decoration: none; color: white; display: block;
  }
  .drawer a:hover { background: #575757; }
  main { margin: 20px; }
</style>
<header>
  <a href="/index.html">← Back to Index</a>
  <button class="menu-btn" onclick="toggleDrawer()">☰ Menu</button>
</header>
<div id="drawer" class="drawer">
  <a href="__test__/terrapin.html">terrapin.html</a>
<a href="afd-slogan-generator.html">afd-slogan-generator.html</a>
<a href="blinker.html">blinker.html</a>
<a href="compose.html">compose.html</a>
<a href="edit-wave-info.html">edit-wave-info.html</a>
<a href="l2r.html">l2r.html</a>
<a href="midi2svg.html">midi2svg.html</a>
<a href="mlogo.html">mlogo.html</a>
<a href="mocr.html">mocr.html</a>
<a href="paint.html">paint.html</a>
<a href="radar.html">radar.html</a>
<a href="reinforcement-policy-neuron-network.html">reinforcement-policy-neuron-network.html</a>
<a href="sprite-detect.html">sprite-detect.html</a>
<a href="sprite.html">sprite.html</a>
<a href="stolzmonat.html">stolzmonat.html</a>
<a href="strwidth.html">strwidth.html</a>
<a href="svgtrace.html">svgtrace.html</a>
<a href="synth.html">synth.html</a>
<a href="terrapin.html">terrapin.html</a>
<a href="tetris.html">tetris.html</a>
<a href="timer.html">timer.html</a>
<a href="westerwald.html">westerwald.html</a>
</div>
<script>
  function toggleDrawer() {
    document.getElementById('drawer').classList.toggle('open');
  }
</script>
</body>
</html>