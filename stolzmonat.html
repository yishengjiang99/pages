<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Profile Image Generator with Tricolor Border</title>
<style>
  body {
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 50px;
  }
  canvas {
    display: none; /* hide canvas */
  }
  #preview {
    border-radius: 50%;
    background-color: #f0f0f0;
    width: 300px;   /* display size */
    height: 300px;  /* display size */
    object-fit: cover;
  }
  input[type="range"] {
    width: 300px;
    margin-top: 20px;
  }
  button {
    margin-top: 20px;
    padding: 8px 16px;
    font-size: 16px;
  }
</style>
</head>
<body>

<h2>Profile Image Generator</h2>
<input type="file" id="upload" accept="image/*">
<img id="preview" alt="Profile preview">
<label for="borderWidthSlider">Border Thickness</label>
<input type="range" id="borderWidthSlider" min="0.5" max="2" step="0.01" value="1.3">
<button id="downloadBtn">Download Image</button>

<!-- Hidden high-res canvas -->
<canvas id="canvas" width="1000" height="1000"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const upload = document.getElementById('upload');
const borderWidthSlider = document.getElementById('borderWidthSlider');
const downloadBtn = document.getElementById('downloadBtn');
const preview = document.getElementById('preview');

let uploadedImg = null;
let borderScale = parseFloat(borderWidthSlider.value);

// Function to build the SVG border dynamically based on scale
function makeBorderSvg(scale) {
  const outerRadius = 480;
  const innerRadius = 480 - (80 * scale); // dynamic thickness
  return `
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
    <defs>
      <clipPath id="circleClip">
        <circle cx="500" cy="500" r="${outerRadius}"/>
        <circle cx="500" cy="500" r="${innerRadius}" fill="white"/>
      </clipPath>
    </defs>
    <g clip-path="url(#circleClip)">
      <rect width="1000" height="333" y="0" fill="black"/>
      <rect width="1000" height="333" y="333" fill="red"/>
      <rect width="1000" height="334" y="666" fill="gold"/>
    </g>
  </svg>
  `;
}

// Generate Image object from SVG string
function svgToImage(svgString) {
  const img = new Image();
  img.src = 'data:image/svg+xml;base64,' + btoa(svgString);
  return img;
}

// Draw function
function drawCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Build border SVG dynamically
  const borderSvgString = makeBorderSvg(borderScale);
  const borderImg = svgToImage(borderSvgString);

  borderImg.onload = () => {
    // Draw border first (bottom layer)
    ctx.drawImage(borderImg, 0, 0, canvas.width, canvas.height);

    // Draw circular clipped content on top
    ctx.save();
    const radius = 400 - (40 * (borderScale - 1)); // match with inner cutout logic
    ctx.beginPath();
    ctx.arc(canvas.width/2, canvas.height/2, radius, 0, Math.PI * 2);
    ctx.closePath();
    ctx.clip();

    if (uploadedImg) {
      const size = Math.min(uploadedImg.width, uploadedImg.height);
      const sx = (uploadedImg.width - size) / 2;
      const sy = (uploadedImg.height - size) / 2;
      ctx.drawImage(uploadedImg, sx, sy, size, size, 0, 0, canvas.width, canvas.height);
    } else {
      // Draw silhouette
      ctx.fillStyle = '#ccc';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    ctx.restore();

    // Update preview <img> from canvas (scaled down)
    preview.src = canvas.toDataURL('image/png');
  };
}

// File upload
upload.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  uploadedImg = new Image();
  uploadedImg.src = URL.createObjectURL(file);
  uploadedImg.onload = drawCanvas;
});

// Border thickness slider
borderWidthSlider.addEventListener('input', (e) => {
  borderScale = parseFloat(e.target.value);
  drawCanvas();
});

// Download button
downloadBtn.addEventListener('click', () => {
  const link = document.createElement('a');
  link.download = 'profile-image.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
});

// Initial preview
drawCanvas();
</script>

</body>
</html>
