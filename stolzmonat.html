<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Profile Image Generator with Tricolor Border</title>
<style>
  body {
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 50px;
  }
  canvas {
    display: none; /* hide canvas */
  }
  #preview {
    border-radius: 50%;
    background-color: #f0f0f0;
    width: 300px;   /* display size */
    height: 300px;  /* display size */
    object-fit: cover;
  }
  input[type="range"] {
    width: 300px;
    margin-top: 20px;
  }
  button {
    margin-top: 20px;
    padding: 8px 16px;
    font-size: 16px;
  }
</style>
</head>
<body>

<h2>Profile Image Generator</h2>
<input type="file" id="upload" accept="image/*">
<img id="preview" alt="Profile preview">
<label for="borderWidthSlider">Border Scale</label>
<input type="range" id="borderWidthSlider" min="0.5" max="2" step="0.01" value="1">
<button id="downloadBtn">Download Image</button>

<!-- Hidden high-res canvas -->
<canvas id="canvas" width="1000" height="1000"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const upload = document.getElementById('upload');
const borderWidthSlider = document.getElementById('borderWidthSlider');
const downloadBtn = document.getElementById('downloadBtn');
const preview = document.getElementById('preview');

let uploadedImg = null;
let borderScale = parseFloat(borderWidthSlider.value);

// Tricolor SVG border (black, red, gold stripes inside a circular border)
const borderSvgString = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">
  <defs>
    <clipPath id="circleClip">
      <circle cx="500" cy="500" r="480"/>
      <circle cx="500" cy="500" r="400" fill="white"/>
    </clipPath>
  </defs>
  <g clip-path="url(#circleClip)">
    <rect width="1000" height="333" y="0" fill="black"/>
    <rect width="1000" height="333" y="333" fill="red"/>
    <rect width="1000" height="334" y="666" fill="gold"/>
  </g>
</svg>
`;

// Convert SVG to Image
const borderImg = new Image();
borderImg.src = 'data:image/svg+xml;base64,' + btoa(borderSvgString);

// Draw function
function drawCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw border first (bottom layer) with scaling
  const borderSize = canvas.width * borderScale;
  const offset = (canvas.width - borderSize) / 2;
  ctx.drawImage(borderImg, offset, offset, borderSize, borderSize);

  // Draw circular clipped content on top
  ctx.save();
  const radius = canvas.width / 2 - (canvas.width * (borderScale - 1) / 2);
  ctx.beginPath();
  ctx.arc(canvas.width/2, canvas.height/2, radius, 0, Math.PI * 2);
  ctx.closePath();
  ctx.clip();

  if (uploadedImg) {
    const size = Math.min(uploadedImg.width, uploadedImg.height);
    const sx = (uploadedImg.width - size) / 2;
    const sy = (uploadedImg.height - size) / 2;
    ctx.drawImage(uploadedImg, sx, sy, size, size, 0, 0, canvas.width, canvas.height);
  } else {
    // Draw silhouette
    ctx.fillStyle = '#ccc';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  ctx.restore();

  // Update preview <img> from canvas (scaled down)
  preview.src = canvas.toDataURL('image/png');
}

// File upload
upload.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  uploadedImg = new Image();
  uploadedImg.src = URL.createObjectURL(file);
  uploadedImg.onload = drawCanvas;
});

// Border scale slider
borderWidthSlider.addEventListener('input', (e) => {
  borderScale = parseFloat(e.target.value);
  drawCanvas();
});

// Download button
downloadBtn.addEventListener('click', () => {
  const link = document.createElement('a');
  link.download = 'profile-image.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
});

// Initial preview
drawCanvas();
</script>

</body>
</html>