<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dominant Color Sprite Frame Detector</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        #output { border: 1px solid #ccc; padding: 10px; min-height: 100px; white-space: pre-wrap; background-color: #f9f9f9; }
        #spriteCanvas { border: 1px solid #000; margin-top: 10px; }
        #previewCanvas { margin-left: 20px; border: 1px dashed #f00; display: inline-block; }
        .canvas-container { display: flex; align-items: flex-start; margin-bottom: 20px; }
    </style>
</head>
<body>

    <h1>Dominant Color Sprite Frame Detector</h1>

    <p>Upload a sprite sheet. All colors *except* the dominant color will be made transparent.</p>
    <input type="file" id="imageLoader" accept="image/png, image/jpeg">
    <label for="colorTolerance">Color Tolerance (0-255):</label>
    <input type="number" id="colorTolerance" value="32" min="1" max="255">
    <button id="processButton">Process Frames</button>

    <div class="canvas-container">
        <div>
            <h3>Processed Image (Hidden Pixels Transparent)</h3>
            <canvas id="spriteCanvas"></canvas>
        </div>
        <div>
            <h3>Original Image Preview</h3>
            <canvas id="previewCanvas"></canvas>
        </div>
    </div>
    
    <p>Frame Offsets (x, y, width, height):</p>
    <div id="output">... Upload an image and click Process ...</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('spriteCanvas');
            const previewCanvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const ptx = previewCanvas.getContext('2d');
            const imageLoader = document.getElementById('imageLoader');
            const processButton = document.getElementById('processButton');
            const outputDiv = document.getElementById('output');
            const toleranceInput = document.getElementById('colorTolerance');

            let imageLoaded = null;

            imageLoader.addEventListener('change', handleImage, false);
            processButton.addEventListener('click', processImage, false);
            processButton.disabled = true;

            function handleImage(e) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        imageLoaded = img;
                        
                        // Set canvas dimensions and draw the image
                        canvas.width = previewCanvas.width = img.width;
                        canvas.height = previewCanvas.height = img.height;
                        
                        ctx.drawImage(img, 0, 0);
                        ptx.drawImage(img, 0, 0);

                        outputDiv.textContent = 'Image loaded. Click Process Frames.';
                        processButton.disabled = false;
                    };
                    img.src = event.target.result;
                };
                if (e.target.files.length > 0) {
                    reader.readAsDataURL(e.target.files[0]);
                }
            }

            function processImage() {
                if (!imageLoaded) {
                    outputDiv.textContent = 'Please load an image first.';
                    return;
                }
                
                // 1. Get initial pixel data
                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let data = imageData.data;
                const width = canvas.width;
                const height = canvas.height;
                const tolerance = parseInt(toleranceInput.value);

                // Reset canvas to original image before analysis
                ctx.drawImage(imageLoaded, 0, 0);
                imageData = ctx.getImageData(0, 0, width, height);
                data = imageData.data;

                // 2. Detect Dominant Color
                const dominantColor = getDominantColor(data);
                if (!dominantColor) {
                    outputDiv.textContent = 'Could not detect a dominant color.';
                    return;
                }
                
                outputDiv.textContent = `Dominant Color detected: RGB(${dominantColor.r}, ${dominantColor.g}, ${dominantColor.b}).\n`;

                // 3. Apply Transparency Filter
                const filteredData = applyTransparencyFilter(data, dominantColor, tolerance, width, height);
                
                // Put the filtered image data back onto the canvas
                ctx.putImageData(filteredData, 0, 0);

                // 4. Detect Frames on the Filtered Image
                const frames = detectFrames(filteredData.data, width, height);
                
                // 5. Print Results
                printResults(frames);
            }

            // --- Dominant Color Detection (Simplified Histogram) ---

            function getDominantColor(data) {
                const colorCounts = new Map();
                const totalPixels = data.length / 4;
                
                // Sample every 4th pixel to speed up processing
                for (let i = 0; i < data.length; i += 16) { 
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Ignore fully transparent pixels (alpha is data[i+3])
                    if (data[i + 3] === 0) continue; 

                    // Quantize colors to reduce the number of unique colors (e.g., to 16-bit color space)
                    // This groups similar colors together, which is crucial for sprite work
                    const r_quant = Math.floor(r / 16) * 16;
                    const g_quant = Math.floor(g / 16) * 16;
                    const b_quant = Math.floor(b / 16) * 16;
                    
                    const colorKey = `${r_quant},${g_quant},${b_quant}`;
                    
                    colorCounts.set(colorKey, (colorCounts.get(colorKey) || 0) + 1);
                }

                if (colorCounts.size === 0) return null;

                // Find the key with the highest count
                let dominantKey = null;
                let maxCount = 0;

                for (const [key, count] of colorCounts.entries()) {
                    if (count > maxCount) {
                        maxCount = count;
                        dominantKey = key;
                    }
                }
                
                const [r, g, b] = dominantKey.split(',').map(Number);
                return { r, g, b };
            }

            // --- Transparency Filter ---

            /**
             * Calculates the squared Euclidean distance between two colors in RGB space.
             * @param {number} r1, g1, b1 First color components.
             * @param {number} r2, g2, b2 Second color components.
             * @returns {number} The squared distance.
             */
            function colorDistanceSquared(r1, g1, b1, r2, g2, b2) {
                return Math.pow(r1 - r2, 2) + Math.pow(g1 - g2, 2) + Math.pow(b1 - b2, 2);
            }

            function applyTransparencyFilter(originalData, dominantColor, tolerance, width, height) {
                // Create a new ImageData object for the filtered result
                const filteredImageData = ctx.createImageData(width, height);
                const data = filteredImageData.data;
                const toleranceSquared = tolerance * tolerance; // Compare squared distance to avoid Math.sqrt

                for (let i = 0; i < originalData.length; i += 4) {
                    const r = originalData[i];
                    const g = originalData[i + 1];
                    const b = originalData[i + 2];
                    
                    // Preserve original transparency if it exists (for PNGs)
                    const originalAlpha = originalData[i + 3];

                    // Calculate distance from the current pixel color to the dominant color
                    const distanceSq = colorDistanceSquared(r, g, b, dominantColor.r, dominantColor.g, dominantColor.b);

                    // If the color is close to the dominant color (within tolerance) AND not already transparent
                    if (distanceSq <= toleranceSquared && originalAlpha > 0) {
                        // Keep the pixel as the dominant color, and make it fully opaque
                        data[i] = dominantColor.r;
                        data[i + 1] = dominantColor.g;
                        data[i + 2] = dominantColor.b;
                        data[i + 3] = 255; // Fully opaque
                    } else {
                        // Treat all other colors as fully transparent
                        data[i] = data[i + 1] = data[i + 2] = 0; // Black (irrelevant, as alpha is 0)
                        data[i + 3] = 0; // Fully transparent
                    }
                }

                return filteredImageData;
            }

            // --- Frame Detection (Same as previous solution) ---

            function isNonTransparent(data, x, y, width) {
                const alphaIndex = (y * width + x) * 4 + 3;
                return data[alphaIndex] > 0;
            }

            function detectFrames(data, width, height) {
                const visited = new Array(width * height).fill(false);
                const frames = [];

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = y * width + x;

                        if (isNonTransparent(data, x, y, width) && !visited[index]) {
                            
                            let minX = x, minY = y, maxX = x, maxY = y;
                            const stack = [{x, y}];
                            visited[index] = true;

                            // Breadth-First Search (BFS) for connected components
                            while (stack.length > 0) {
                                const {x: cx, y: cy} = stack.pop();

                                minX = Math.min(minX, cx);
                                minY = Math.min(minY, cy);
                                maxX = Math.max(maxX, cx);
                                maxY = Math.max(maxY, cy);

                                const neighbors = [
                                    {nx: cx + 1, ny: cy}, {nx: cx - 1, ny: cy}, 
                                    {nx: cx, ny: cy + 1}, {nx: cx, ny: cy - 1}
                                ];

                                for (const {nx, ny} of neighbors) {
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                        const nIndex = ny * width + nx;
                                        if (isNonTransparent(data, nx, ny, width) && !visited[nIndex]) {
                                            visited[nIndex] = true;
                                            stack.push({x: nx, y: ny});
                                        }
                                    }
                                }
                            }

                            // Calculate final frame dimensions
                            const frame = {
                                x: minX,
                                y: minY,
                                width: maxX - minX + 1,
                                height: maxY - minY + 1
                            };
                            frames.push(frame);
                        }
                    }
                }

                return frames;
            }

            function printResults(frames) {
                let currentOutput = outputDiv.textContent;
                
                if (frames.length === 0) {
                    currentOutput += '\n\n**No non-transparent frames detected after filtering.**';
                    outputDiv.textContent = currentOutput;
                    return;
                }

                let output = '\n--- Detected Frames ---\n';
                frames.forEach((frame, index) => {
                    output += `Frame ${index + 1}: x: ${frame.x}, y: ${frame.y}, width: ${frame.width}, height: ${frame.height}\n`;
                });

                outputDiv.textContent = currentOutput + output;
            }

        });
    </script>

</body>
</html>
