<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sprite Frame Detector</title>
    <style>
        /* Optional basic styling */
        body { font-family: Arial, sans-serif; margin: 20px; }
        #output { border: 1px solid #ccc; padding: 10px; min-height: 100px; white-space: pre-wrap; background-color: #f9f9f9; }
        #spriteCanvas { border: 1px solid #000; display: none; /* Hide the canvas, it's just for processing */ }
    </style>
</head>
<body>

    <h1>Sprite Frame Detector</h1>

    <p>Upload a sprite sheet with non-transparent frames separated by transparent pixels.</p>
    <input type="file" id="imageLoader" accept="image/png">
    <p>Frame Offsets (x, y, width, height):</p>
    <div id="output">... Upload an image to see results ...</div>

    <canvas id="spriteCanvas"></canvas>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('spriteCanvas');
            const ctx = canvas.getContext('2d');
            const imageLoader = document.getElementById('imageLoader');
            const outputDiv = document.getElementById('output');

            imageLoader.addEventListener('change', handleImage, false);

            function handleImage(e) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // Set canvas dimensions to the image size
                        canvas.width = img.width;
                        canvas.height = img.height;
                        
                        // Draw the image onto the canvas
                        ctx.drawImage(img, 0, 0);
                        
                        // Get the pixel data from the canvas
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        // Run the detection algorithm
                        const frames = detectFrames(data, canvas.width, canvas.height);
                        
                        // Print the results
                        printResults(frames);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(e.target.files[0]);
            }

            /**
             * Checks if a pixel at (x, y) is non-transparent.
             * @param {Uint8ClampedArray} data The image data array.
             * @param {number} x The x-coordinate.
             * @param {number} y The y-coordinate.
             * @param {number} width The width of the image.
             * @returns {boolean} True if the pixel is non-transparent.
             */
            function isNonTransparent(data, x, y, width) {
                // Pixels are stored as R, G, B, A (alpha) in the array
                // The alpha channel is at index (y * width + x) * 4 + 3
                const alphaIndex = (y * width + x) * 4 + 3;
                // An alpha value of 0 means fully transparent
                return data[alphaIndex] > 0;
            }

            /**
             * The core algorithm to find connected non-transparent areas (frames).
             * Uses a simple flooding/scanning technique.
             * @param {Uint8ClampedArray} data The image data.
             * @param {number} width The image width.
             * @param {number} height The image height.
             * @returns {Array<Object>} An array of frame objects {x, y, width, height}.
             */
            function detectFrames(data, width, height) {
                const visited = new Array(width * height).fill(false);
                const frames = [];

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = y * width + x;

                        // Check if it's an unvisited, non-transparent pixel
                        if (isNonTransparent(data, x, y, width) && !visited[index]) {
                            
                            // Start of a new frame, perform a scan to find its bounds
                            let minX = x, minY = y, maxX = x, maxY = y;
                            const stack = [{x, y}];
                            visited[index] = true;

                            // Simple Breadth-First Search (BFS) for connected components
                            while (stack.length > 0) {
                                const {x: cx, y: cy} = stack.pop();

                                // Update frame bounds
                                minX = Math.min(minX, cx);
                                minY = Math.min(minY, cy);
                                maxX = Math.max(maxX, cx);
                                maxY = Math.max(maxY, cy);

                                // Check neighbors (up, down, left, right)
                                const neighbors = [
                                    {nx: cx + 1, ny: cy}, {nx: cx - 1, ny: cy}, 
                                    {nx: cx, ny: cy + 1}, {nx: cx, ny: cy - 1}
                                ];

                                for (const {nx, ny} of neighbors) {
                                    // Check boundary conditions
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                        const nIndex = ny * width + nx;
                                        // If non-transparent and unvisited, add to stack and mark as visited
                                        if (isNonTransparent(data, nx, ny, width) && !visited[nIndex]) {
                                            visited[nIndex] = true;
                                            stack.push({x: nx, y: ny});
                                        }
                                    }
                                }
                            }

                            // Calculate final frame dimensions and push
                            const frame = {
                                x: minX,
                                y: minY,
                                width: maxX - minX + 1,
                                height: maxY - minY + 1
                            };
                            frames.push(frame);
                        }
                    }
                }

                return frames;
            }

            /**
             * Prints the detected frame offsets to the output div.
             * @param {Array<Object>} frames The array of detected frames.
             */
            function printResults(frames) {
                if (frames.length === 0) {
                    outputDiv.textContent = 'No non-transparent frames detected.';
                    return;
                }

                let output = '';
                frames.forEach((frame, index) => {
                    output += `Frame ${index + 1}: x: ${frame.x}, y: ${frame.y}, width: ${frame.width}, height: ${frame.height}\n`;
                });

                outputDiv.textContent = output;
            }

        });
    </script>

</body>
</html>
