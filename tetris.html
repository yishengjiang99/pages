<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Mobile Tetris</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      background-color: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
      padding-top: 10px;
    }
    #gameContainer {
      text-align: center;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #startBtn {
      background-color: #fff;
      color: #000;
      border: none;
      padding: 15px 30px;
      font-size: 18px;
      border-radius: 5px;
      cursor: pointer;
      margin-bottom: 10px;
    }
    #startBtn:hover { background-color: #ccc; }
    #score {
      color: #fff;
      font-size: 24px;
      margin-bottom: 10px;
      display: none;
    }
    canvas {
      border: 2px solid #fff;
      background-color: #111;
      touch-action: none;
      display: none;
    }
    footer {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: #000;
      color: #fff;
      z-index: 100;
    }
    #errors {
      margin: 0;
      padding: 5px;
      font-size: 12px;
      max-height: 100px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    @media (orientation: landscape) {
      body::before {
        content: "Please rotate your device to portrait mode";
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.9);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        z-index: 1000;
      }
      #gameContainer { display: none; }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <button id="startBtn">Start Game</button>
    <div id="score">Score: 0</div>
    <canvas id="tetris"></canvas>
  </div>
  <footer>
    <pre id="errors"></pre>
  </footer>

  <script>
    // Error handling
    window.addEventListener('error', e => {
      const pre = document.getElementById('errors');
      if (pre) pre.textContent += (e.error ? e.error.stack : e.message) + '\n';
      return false;
    });
    window.addEventListener('unhandledrejection', e => {
      const pre = document.getElementById('errors');
      if (pre) pre.textContent += 'Promise rejection: ' + (e.reason || 'Unknown') + '\n';
    });

    class TetrisGame {
      constructor(audioContext) {
        this.canvas = document.getElementById('tetris');
        this.ctx = this.canvas.getContext('2d');
        this.scoreElement = document.getElementById('score');
        this.score = 0;

        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        this.board = this.createBoard();
        this.currentPiece = this.getNewPiece();
        this.nextPiece = this.getNewPiece();
        this.dropTime = 0;
        this.dropInterval = 1000;
        this.lastTime = performance.now();
        this.audioContext = audioContext;
        this.isGameOver = false;

        // Pointer input
        this.pointerActive = false;
        this.pointerStartX = 0;
        this.pointerStartY = 0;

        this.canvas.addEventListener('pointerdown', e => this.handlePointerDown(e));
        this.canvas.addEventListener('pointermove', e => this.handlePointerMove(e));
        this.canvas.addEventListener('pointerup', e => this.handlePointerUp(e));
        this.canvas.addEventListener('pointercancel', e => this.handlePointerUp(e));

        // Desktop fallback: click to rotate
        this.canvas.addEventListener('click', e => { if (!this.pointerActive) this.rotatePiece(); });

        this.gameLoop = this.gameLoop.bind(this);
        requestAnimationFrame(this.gameLoop);
      }

      resizeCanvas() {
        const padding = 60;
        this.blockSize = Math.min(window.innerWidth * 0.95 / 10, (window.innerHeight - padding) / 20);
        this.canvas.width = 10 * this.blockSize;
        this.canvas.height = 20 * this.blockSize;
        this.cols = 10;
        this.rows = 20;
      }

      createBoard() {
        return Array.from({ length: this.rows }, () => Array(this.cols).fill(0));
      }

      getNewPiece() {
        const pieces = 'I O T S Z J L'.split(' ');
        const type = pieces[Math.floor(Math.random() * pieces.length)];
        return {
          type,
          shape: this.getShape(type),
          row: 0,
          col: Math.floor(this.cols / 2) - 1,
          color: this.getColor(type)
        };
      }

      getShape(type) {
        const shapes = {
          I: [[[1,1,1,1]]],
          O: [[[1,1],[1,1]]],
          T: [[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]],
          S: [[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]],
          Z: [[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]],
          J: [[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]],
          L: [[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]]
        };
        return shapes[type][0];
      }

      getColor(type) {
        const colors = {
          I: '#00f0f0', O: '#f0f000', T: '#a000f0',
          S: '#00f000', Z: '#f00000', J: '#0000f0', L: '#f0a000'
        };
        return colors[type];
      }

      drawBlock(x, y, color) {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x * this.blockSize, y * this.blockSize, this.blockSize, this.blockSize);
        this.ctx.strokeStyle = '#000';
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(x * this.blockSize, y * this.blockSize, this.blockSize, this.blockSize);
      }

      drawBoard() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.cols; col++) {
            if (this.board[row][col]) this.drawBlock(col, row, this.board[row][col]);
          }
        }
        this.drawPiece(this.currentPiece);
      }

      drawPiece(piece) {
        piece.shape.forEach((row, dy) => {
          row.forEach((value, dx) => {
            if (value) this.drawBlock(piece.col + dx, piece.row + dy, piece.color);
          });
        });
      }

      validMove(piece, rowOffset = 0, colOffset = 0, shape = null) {
        const testShape = shape || piece.shape;
        for (let dy = 0; dy < testShape.length; dy++) {
          for (let dx = 0; dx < testShape[dy].length; dx++) {
            if (testShape[dy][dx]) {
              const newRow = piece.row + dy + rowOffset;
              const newCol = piece.col + dx + colOffset;
              if (newRow >= this.rows || newCol < 0 || newCol >= this.cols || (newRow >= 0 && this.board[newRow][newCol])) {
                return false;
              }
            }
          }
        }
        return true;
      }

      placePiece() {
        this.currentPiece.shape.forEach((row, dy) => {
          row.forEach((value, dx) => {
            if (value) {
              const y = this.currentPiece.row + dy;
              const x = this.currentPiece.col + dx;
              if (y >= 0) this.board[y][x] = this.currentPiece.color;
            }
          });
        });
        this.clearLines();
        this.currentPiece = this.nextPiece;
        this.nextPiece = this.getNewPiece();
        if (!this.validMove(this.currentPiece)) this.gameOver();
        this.playSound(200, 0.1);
      }

      clearLines() {
        let linesCleared = 0;
        for (let row = this.rows - 1; row >= 0; row--) {
          if (this.board[row].every(cell => cell !== 0)) {
            this.board.splice(row, 1);
            this.board.unshift(Array(this.cols).fill(0));
            linesCleared++;
            row++;
          }
        }
        if (linesCleared > 0) {
          this.score += linesCleared * 100;
          this.scoreElement.textContent = `Score: ${this.score}`;
          this.dropInterval = Math.max(100, this.dropInterval - 50 * linesCleared);
          this.playSound(400 + linesCleared * 200, 0.2);
        }
      }

      rotatePiece() {
        const rotated = this.currentPiece.shape[0].map((_, i) => this.currentPiece.shape.map(r => r[i]).reverse());
        if (this.validMove(this.currentPiece, 0, 0, rotated)) {
          this.currentPiece.shape = rotated;
          this.playSound(600, 0.05);
        }
      }

      moveDown(steps = 1) {
        for (let i = 0; i < steps; i++) {
          if (this.validMove(this.currentPiece, 1)) {
            this.currentPiece.row++;
            this.playSound(100, 0.02);
          } else {
            this.placePiece();
            break;
          }
        }
      }

      moveHorizontal(steps) {
        if (steps === 0) return;
        let moved = 0;
        while (moved !== steps) {
          if (steps > 0 && this.validMove(this.currentPiece, 0, 1)) {
            this.currentPiece.col++;
            moved++;
          } else if (steps < 0 && this.validMove(this.currentPiece, 0, -1)) {
            this.currentPiece.col--;
            moved--;
          } else break;
        }
        if (moved !== 0) this.playSound(150, 0.02);
      }

      gameOver() {
        this.isGameOver = true;
        this.playSound(100, 0.5);
        alert(`Game Over! Score: ${this.score}`);
      }

      playSound(f, d) {
        if (this.audioContext.state === 'suspended') this.audioContext.resume();
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        osc.connect(gain);
        gain.connect(this.audioContext.destination);
        osc.frequency.value = f;
        osc.type = 'square';
        gain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + d);
        osc.start(this.audioContext.currentTime);
        osc.stop(this.audioContext.currentTime + d);
      }

      handlePointerDown(e) {
        e.preventDefault();
        this.pointerActive = true;
        this.pointerStartX = e.clientX;
        this.pointerStartY = e.clientY;
      }

      handlePointerMove(e) {
        if (!this.pointerActive || this.isGameOver) return;

        const deltaX = (e.clientX - this.pointerStartX) * 0.9;
        const deltaY = (e.clientY - this.pointerStartY) * 0.9;

        const stepsX = Math.round(deltaX / this.blockSize);
        const stepsY = Math.round(deltaY / this.blockSize);

        if (stepsX !== 0) {
          this.moveHorizontal(stepsX);
          this.pointerStartX = e.clientX;
        }
        if (stepsY > 0) { // Only downward drag
          this.moveDown(stepsY);
          this.pointerStartY = e.clientY;
        }
      }

      handlePointerUp(e) {
        this.pointerActive = false;
      }

      gameLoop(currentTime = 0) {
        if (this.isGameOver) return;
        const deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;
        this.dropTime += deltaTime;
        if (this.dropTime > this.dropInterval) {
          this.moveDown();
          this.dropTime = 0;
        }
        this.drawBoard();
        requestAnimationFrame(this.gameLoop);
      }
    }

    document.getElementById('startBtn').addEventListener('click', async () => {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      await audioContext.resume();
      document.getElementById('startBtn').style.display = 'none';
      document.getElementById('score').style.display = 'block';
      document.getElementById('tetris').style.display = 'block';
      new TetrisGame(audioContext);
    });
  </script>
</body>
</html>