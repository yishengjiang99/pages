<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Logo Editor</title>
<style>
html,body{
  margin:0;
  padding:0;
  height:100%;
  overflow:hidden;
  touch-action:none;
  font-family:sans-serif;
  -webkit-user-select:none;
  user-select:none;
}
#editor{
  position:absolute;
  top:0;
  bottom:120px;
  left:0;
  right:0;
  min-height:200px;
}
#drawer{
  position:fixed;
  top:0;
  right:-100%;
  width:80%;
  max-width:500px;
  height:100%;
  background:#fff;
  box-shadow:-2px 0 5px rgba(0,0,0,0.3);
  transition:right 0.3s ease;
  z-index:100;
  display:flex;
  flex-direction:column;
}
#drawer.show{ right:0; }
#svgContainer{ flex:1; overflow:hidden; background:#fafafa; }
#controls{
  position:fixed;
  bottom:0;
  left:0;
  right:0;
  background:#eee;
  display:grid;
  grid-template-rows:auto auto auto;
  gap:2px;
  padding:4px 2px calc(env(safe-area-inset-bottom) + 4px) 2px;
  z-index:200;
}
.controls-row{
  display:flex;
  justify-content:center;
  gap:2px;
}
button{
  flex:1;
  padding:10px;
  font-size:16px;
  border:none;
  border-radius:4px;
  background:#ddd;
}
button:active{ background:#bbb; }
</style>
</head>
<body>
<div id="editor"></div>
<div id="drawer"><div id="svgContainer"><svg id="turtleSVG"></svg></div></div>
<div id="controls">
 <div class="controls-row">
   <button onclick="appendCommand('FD')">FD</button>
   <button onclick="appendCommand('BK')">BK</button>
   <button onclick="appendCommand('RT')">RT</button>
   <button onclick="appendCommand('LT')">LT</button>
   <button onclick="appendCommand('PU')">PU</button>
   <button onclick="appendCommand('PD')">PD</button>
   <button onclick="appendCommand('CS')">CS</button>
   <button onclick="appendCommand('HM')">HM</button>
 </div>
 <div class="controls-row">
   <button onclick="appendCommand('10')">10</button>
   <button onclick="appendCommand('45')">45</button>
   <button onclick="appendCommand('90')">90</button>
 </div>
 <div class="controls-row">
   <button onclick="runCommands()">Run</button>
   <button onclick="resetEditor()">Reset</button>
   <button onclick="shareCode()">Share</button>
   <button onclick="showDrawer()">Show</button>
 </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
<script>
let editor, markers=[];
require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' }});
require(['vs/editor/editor.main'], function(){
  editor = monaco.editor.create(document.getElementById('editor'), {
    value:'',
    language:'plaintext',
    theme:'vs-dark',
    automaticLayout:true,
    minimap:{enabled:false}
  });

  // Long press to show command palette (simplified)
  let pressTimer;
  editor.onMouseDown(()=>{
    clearTimeout(pressTimer);
    pressTimer=setTimeout(()=>{alert('Command Palette (not yet implemented)');},600);
  });
  editor.onMouseUp(()=>clearTimeout(pressTimer));

  // parse check
  editor.onDidChangeModelContent(()=>{
    const input=editor.getValue();
    try{ tokenizeInput(input); clearMarkers(); }
    catch(e){ markError(e.message); }
  });

  // load from hash
  const hash=location.hash.slice(1);
  if(hash){
    try{ editor.setValue(atob(hash)); }catch(e){}
  } else {
    editor.setValue(`CS\nREPEAT 5 [\n  FD 100\n  RT 144\n]`);
  }

  // initial parse
  try{ tokenizeInput(editor.getValue()); clearMarkers(); }
  catch(e){ markError(e.message); }
});

function clearMarkers(){ monaco.editor.setModelMarkers(editor.getModel(),"owner",[]); }
function markError(msg){ monaco.editor.setModelMarkers(editor.getModel(),"owner",[{
  startLineNumber:1,startColumn:1,endLineNumber:1,endColumn:1,
  message:msg,severity:monaco.MarkerSeverity.Error
}]); }
function appendCommand(cmd){
  const pos=editor.getPosition();
  editor.executeEdits("insert-cmd",[{
    range:new monaco.Range(pos.lineNumber,pos.column,pos.lineNumber,pos.column),
    text:cmd+" ",
    forceMoveMarkers:true
  }]);
  editor.focus();
}
function resetEditor(){ editor.setValue(''); initTurtle(); }
function shareCode(){
  const val=editor.getValue();
  const url=location.origin+location.pathname+'#'+btoa(val);
  navigator.clipboard.writeText(url);
  alert("Link copied!");
}

// Drawer
function showDrawer(){ document.getElementById('drawer').classList.add('show'); }
function openDrawer(){ showDrawer(); }
function hideDrawer(){ document.getElementById('drawer').classList.remove('show'); }

// Turtle SVG
const svg=document.getElementById('turtleSVG');
let turtle, zoom=1, pan={x:0,y:0}, paths=[];
function setSVGSize(){ svg.setAttribute('width','100%'); svg.setAttribute('height','100%'); drawTurtle(); }
function initTurtle(){ turtle={x:svg.clientWidth/2,y:svg.clientHeight/2,angle:0,penDown:true}; paths=[]; drawTurtle(); }
function drawTurtle(){
  while(svg.firstChild) svg.removeChild(svg.firstChild);
  const g=document.createElementNS("http://www.w3.org/2000/svg","g");
  g.setAttribute("transform",`translate(${pan.x},${pan.y}) scale(${zoom})`);
  paths.forEach(p=>g.appendChild(p));
  const tri=document.createElementNS("http://www.w3.org/2000/svg","polygon");
  tri.setAttribute("points","0,-10 -5,5 5,5");
  tri.setAttribute("fill","green");
  tri.setAttribute("transform",`translate(${turtle.x},${turtle.y}) rotate(${turtle.angle})`);
  g.appendChild(tri);
  svg.appendChild(g);
}
function moveTurtle(d){
  const rad=turtle.angle*Math.PI/180;
  const nx=turtle.x+Math.cos(rad)*d, ny=turtle.y+Math.sin(rad)*d;
  if(turtle.penDown){
    const line=document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1",turtle.x); line.setAttribute("y1",turtle.y);
    line.setAttribute("x2",nx); line.setAttribute("y2",ny);
    line.setAttribute("stroke","black");
    paths.push(line);
  }
  turtle.x=nx; turtle.y=ny;
  drawTurtle();
}

// Tokenizer & executor
function tokenizeInput(input){return input.trim().split(/\s+/);}
function executeTokens(tokens){
  let i=0;
  function exec(){
    while(i<tokens.length){
      let cmd=tokens[i++].toUpperCase();
      if(cmd==='FD'){ moveTurtle(parseFloat(tokens[i++])); }
      else if(cmd==='BK'){ moveTurtle(-parseFloat(tokens[i++])); }
      else if(cmd==='RT'){ turtle.angle+=parseFloat(tokens[i++]); drawTurtle(); }
      else if(cmd==='LT'){ turtle.angle-=parseFloat(tokens[i++]); drawTurtle(); }
      else if(cmd==='PU'){ turtle.penDown=false; }
      else if(cmd==='PD'){ turtle.penDown=true; }
      else if(cmd==='CS'){ initTurtle(); }
      else if(cmd==='HM'){ turtle.x=svg.clientWidth/2; turtle.y=svg.clientHeight/2; turtle.angle=0; drawTurtle(); }
      else if(cmd==='SETXY'){ let x=parseFloat(tokens[i++]); let y=parseFloat(tokens[i++]); if(!isNaN(x)&&!isNaN(y)){ turtle.x=svg.clientWidth/2+x; turtle.y=svg.clientHeight/2-y; drawTurtle(); } }
      else if(cmd==='SETH'||cmd==='SETHEADING'){ let a=parseFloat(tokens[i++]); if(!isNaN(a)){ turtle.angle=a; drawTurtle(); } }
      else if(cmd==='REPEAT'){ 
        let count=parseInt(tokens[i++]); 
        if(tokens[i++]!=='[') throw new Error("Expected [");
        let bs=i, depth=1; 
        while(i<tokens.length&&depth>0){ if(tokens[i]==='[') depth++; else if(tokens[i]===']') depth--; i++; }
        let block=tokens.slice(bs,i-1);
        for(let j=0;j<count;j++){ let saved=tokens,si=i; tokens=block; i=0; exec(); tokens=saved;i=si; }
      }
      else if(cmd===']'){ return; }
      else{ throw new Error("Unknown command: "+cmd); }
    }
  }
  exec();
}
function runCommands(){ openDrawer(); initTurtle(); const tokens=tokenizeInput(editor.getValue()); executeTokens(tokens); }

// Zoom/Pan
let pointers={}, lastDistance=null;
svg.addEventListener('wheel',e=>{ e.preventDefault(); zoom*=e.deltaY<0?1.1:0.9; drawTurtle(); });
svg.addEventListener('pointerdown',e=>{ pointers[e.pointerId]=e; svg.setPointerCapture(e.pointerId); e.preventDefault(); });
svg.addEventListener('pointermove',e=>{
  if(!pointers[e.pointerId]) return; pointers[e.pointerId]=e; e.preventDefault();
  const ids=Object.keys(pointers);
  if(ids.length===1){
    let dx=e.clientX-pointers[ids[0]].clientX; let dy=e.clientY-pointers[ids[0]].clientY;
    pan.x+=dx; pan.y+=dy; pointers[ids[0]]=e;
  } else if(ids.length===2){
    let t1=pointers[ids[0]],t2=pointers[ids[1]]; let curr=Math.hypot(t2.clientX-t1.clientX,t2.clientY-t1.clientY);
    if(lastDistance!=null){ let scale=curr/lastDistance; zoom*=scale; let midX=(t1.clientX+t2.clientX)/2,midY=(t1.clientY+t2.clientY)/2; pan.x=pan.x*scale+midX*(1-scale); pan.y=pan.y*scale+midY*(1-scale); }
    lastDistance=curr;
  }
  drawTurtle();
});
svg.addEventListener('pointerup',e=>{ delete pointers[e.pointerId]; if(Object.keys(pointers).length<2) lastDistance=null; });
svg.addEventListener('pointercancel',e=>{ delete pointers[e.pointerId]; if(Object.keys(pointers).length<2) lastDistance=null; });
window.addEventListener('resize',setSVGSize);
setSVGSize(); initTurtle();
</script>
</body>
</html>