<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Terrapin Logo Emulator</title>
    <style>
        /* Your existing CSS remains unchanged */
    </style>
</head>

<body>
    <h1>Terrapin Logo Emulator</h1>
    <canvas id="turtleCanvas"></canvas>
    <textarea id="commandInput" placeholder="Enter Logo commands or use buttons below"></textarea>
    <pre id="debug"></pre>
    <div class="controls command-buttons">
        <button onclick="appendCommand('FORWARD')">FORWARD</button>
        <button onclick="appendCommand('BACK')">BACK</button>
        <button onclick="appendCommand('RIGHT')">RIGHT</button>
        <button onclick="appendCommand('LEFT')">LEFT</button>
        <button onclick="appendCommand('PENUP')">PENUP</button>
        <button onclick="appendCommand('PENDOWN')">PENDOWN</button>
        <button onclick="appendCommand('CLEARSCREEN')">CLEARSCREEN</button>
        <button onclick="appendCommand('HOME')">HOME</button>
        <button onclick="appendCommand('REPEAT')">REPEAT</button> <!-- Added REPEAT button -->
    </div>
    <div class="controls number-buttons">
        <button onclick="appendCommand('10')">10</button>
        <button onclick="appendCommand('50')">50</button>
        <button onclick="appendCommand('100')">100</button>
    </div>
    <div class="controls action-buttons">
        <button class="run-button" onclick="runCommands()">Run Commands</button>
        <button class="reset-button" onclick="resetEditor()">Reset</button>
        <button class="sample-button" onclick="loadSample()">Sample</button>
    </div>

    <script>
        // Get canvas and editor
        const canvas = document.getElementById('turtleCanvas');
        const ctx = canvas.getContext('2d');
        const commandInput = document.getElementById('commandInput');

        // Set canvas size
        const setCanvasSize = () => {
            const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.4, 400);
            canvas.width = size;
            canvas.height = size;
            initCanvas();
        };

        // Turtle state
        let turtle = {
            x: 0,
            y: 0,
            angle: 0,
            penDown: true
        };

        // Store procedures
        let procedures = {};

        // Initialize canvas
        function initCanvas() {
            turtle.x = canvas.width / 2;
            turtle.y = canvas.height / 2;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            turtle.angle = 0;
            turtle.penDown = true;
            drawTurtle();
        }

        // Draw turtle
        function drawTurtle() {
            ctx.save();
            ctx.translate(turtle.x, turtle.y);
            ctx.rotate((turtle.angle * Math.PI) / 180);
            ctx.fillStyle = 'green';
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.lineTo(-5, 5);
            ctx.lineTo(5, 5);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // Append command to editor
        function appendCommand(cmd) {
            if (/\d+/.test(cmd)) {
                if (commandInput.value.endsWith(' ')) {
                    commandInput.value = commandInput.value.trimEnd() + ' ' + cmd + '\n';
                } else {
                    commandInput.value += cmd + '\n';
                }
            } else {
                commandInput.value += cmd + ' ';
            }
            commandInput.focus();
        }

        // Reset editor and canvas
        function resetEditor() {
            commandInput.value = '';
            procedures = {}; // Clear procedures
            initCanvas();
        }

        // Load sample sequence (six-petal flower)
        function loadSample() {
            commandInput.value = `TO FLOWER
  REPEAT 6 [
    REPEAT 36 [
      FORWARD 5
      RIGHT 5
    ]
    RIGHT 180
    REPEAT 36 [
      FORWARD 5
      RIGHT 5
    ]
    RIGHT 180
    RIGHT 60
  ]
END
CLEARSCREEN
PENUP
SETXY 0 0
PENDOWN
FLOWER`;
            commandInput.focus();
        }

        // Parse command blocks (e.g., REPEAT or procedure bodies)
        function parseBlock(tokens, startIndex) {
            let index = startIndex;
            let block = [];
            let depth = 0;

            if (tokens[index] !== '[') return { commands: [], nextIndex: index };

            index++;
            while (index < tokens.length) {
                const token = tokens[index];
                if (token === '[') {
                    depth++;
                    block.push(token);
                } else if (token === ']') {
                    depth--;
                    if (depth === 0) {
                        index++;
                        break;
                    }
                    block.push(token);
                } else {
                    block.push(token);
                }
                index++;
            }

            return { commands: block, nextIndex: index };
        }

        // Tokenize input, preserving blocks
        function tokenizeInput(input) {
            const tokens = [];
            let currentToken = '';
            let i = 0;
            let inBlock = false;

            while (i < input.length) {
                const char = input[i];
                if (char === '[' || char === ']') {
                    if (currentToken) {
                        tokens.push(currentToken.trim());
                        currentToken = '';
                    }
                    tokens.push(char);
                    inBlock = (char === '[');
                } else if (/\s/.test(char) && !inBlock) {
                    if (currentToken) {
                        tokens.push(currentToken.trim());
                        currentToken = '';
                    }
                } else {
                    currentToken += char;
                }
                i++;
            }
            if (currentToken) tokens.push(currentToken.trim());
            return tokens.filter(token => token !== '');
        }

        // Execute a list of tokens
        function executeCommands(tokens, startIndex = 0) {
            let i = startIndex;
            while (i < tokens.length) {
                const cmd = tokens[i].toUpperCase();
                if (cmd === 'TO') {
                    i++;
                    const procName = tokens[i];
                    i++;
                    const { commands: procBody, nextIndex } = parseBlock(tokens, i);
                    if (tokens[nextIndex] === 'END') {
                        procedures[procName.toUpperCase()] = procBody;
                        i = nextIndex + 1;
                    } else {
                        console.warn(`Missing END for procedure ${procName}`);
                        return;
                    }
                } else if (cmd === 'REPEAT') {
                    i++;
                    const count = parseInt(tokens[i]);
                    if (isNaN(count)) {
                        console.warn(`Invalid REPEAT count: ${tokens[i]}`);
                        return;
                    }
                    i++;
                    const { commands: block, nextIndex } = parseBlock(tokens, i);
                    for (let j = 0; j < count; j++) {
                        executeCommands(block);
                    }
                    i = nextIndex;
                } else if (cmd === 'FORWARD' || cmd === 'FD') {
                    i++;
                    const arg = parseFloat(tokens[i]);
                    if (!isNaN(arg)) moveTurtle(arg);
                    else console.warn(`Invalid argument for ${cmd}: ${tokens[i]}`);
                    i++;
                } else if (cmd === 'BACK' || cmd === 'BK') {
                    i++;
                    const arg = parseFloat(tokens[i]);
                    if (!isNaN(arg)) moveTurtle(-arg);
                    else console.warn(`Invalid argument for ${cmd}: ${tokens[i]}`);
                    i++;
                } else if (cmd === 'RIGHT' || cmd === 'RT') {
                    i++;
                    const arg = parseFloat(tokens[i]);
                    if (!isNaN(arg)) turtle.angle = (turtle.angle + arg) % 360;
                    else console.warn(`Invalid argument for ${cmd}: ${tokens[i]}`);
                    i++;
                } else if (cmd === 'LEFT' || cmd === 'LT') {
                    i++;
                    const arg = parseFloat(tokens[i]);
                    if (!isNaN(arg)) turtle.angle = (turtle.angle - arg) % 360;
                    else console.warn(`Invalid argument for ${cmd}: ${tokens[i]}`);
                    i++;
                } else if (cmd === 'PENUP' || cmd === 'PU') {
                    turtle.penDown = false;
                    i++;
                } else if (cmd === 'PENDOWN' || cmd === 'PD') {
                    turtle.penDown = true;
                    i++;
                } else if (cmd === 'CLEARSCREEN' || cmd === 'CS') {
                    initCanvas();
                    i++;
                } else if (cmd === 'HOME') {
                    turtle.x = canvas.width / 2;
                    turtle.y = canvas.height / 2;
                    turtle.angle = 0;
                    i++;
                } else if (cmd === 'SETXY') {
                    i++;
                    const x = parseFloat(tokens[i]);
                    i++;
                    const y = parseFloat(tokens[i]);
                    if (!isNaN(x) && !isNaN(y)) {
                        turtle.x = canvas.width / 2 + x;
                        turtle.y = canvas.height / 2 - y; // Adjust for canvas coordinates
                    } else {
                        console.warn(`Invalid arguments for SETXY: ${tokens[i-1]}, ${tokens[i]}`);
                    }
                    i++;
                } else if (procedures[cmd]) {
                    executeCommands(procedures[cmd]);
                    i++;
                } else {
                    console.warn(`Unknown command: ${cmd}`);
                    i++;
                }
            }
            drawTurtle();
        }

        // Move turtle
        function moveTurtle(distance) {
            if (isNaN(distance)) return;
            const rad = (turtle.angle * Math.PI) / 180;
            const newX = turtle.x + distance * Math.cos(rad);
            const newY = turtle.y - distance * Math.sin(rad);

            if (turtle.penDown) {
                ctx.beginPath();
                ctx.moveTo(turtle.x, turtle.y);
                ctx.lineTo(newX, newY);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            turtle.x = newX;
            turtle.y = newY;
        }

        // Parse and execute commands
        function runCommands() {
            const input = commandInput.value.trim();
            if (!input) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const tokens = tokenizeInput(input);
            executeCommands(tokens);
        }

        // Initialize and handle resize
        window.addEventListener('resize', setCanvasSize);
        setCanvasSize();
    </script>
</body>

</html>