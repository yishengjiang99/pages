<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Goertzel Piano Roll with Hann Window</title>
<style>
  body { margin: 0; overflow: hidden; font-family: sans-serif; user-select: none; -webkit-user-select: none; touch-action: manipulation; }
  #controls { display: flex; flex-wrap: wrap; gap: 8px; padding: 8px; background: #222; color: #fff; align-items: center; }
  button, input[type=range] { font-size: 18px; padding: 10px; border-radius: 6px; border: none; }
  button { background: #4CAF50; color: white; }
  .volumeContainer, .noiseGateContainer { display: flex; flex-direction: column; align-items: flex-start; margin-left: 8px; }
  #volume { width: 150px; height: 20px; background: #555; position: relative; }
  #volumeLevel { height: 100%; width: 0%; background: lime; }
  #volumeText { font-size: 12px; color: #fff; margin-top: 2px; }
  #noiseGateSlider { width: 150px; }
  #pianoContainer { display: flex; height: 600px; overflow: hidden; border-top: 1px solid #ccc; }
  #pianoAxis { width: 60px; background: #eee; border-right: 1px solid #ccc; }
  #pianoAxis svg { width: 60px; height: 100%; display: block; }
  #pianoRollWrapper { flex: 1; overflow-x: scroll; overflow-y: hidden; background: #111; }
  #pianoRoll { height: 600px; }
  #log { height: 120px; overflow-y: scroll; background: #000; color: #0f0; padding: 4px; font-size: 12px; white-space: pre-wrap; }
</style>
</head>
<body>
<div id="controls">
  <button id="startBtn">Start</button>
  <button id="stopBtn">Stop</button>
  <button id="exportBtn">Export MIDI</button>

  <div class="volumeContainer">
    <label>Volume:</label>
    <div id="volume"><div id="volumeLevel"></div></div>
    <div id="volumeText">0.00</div>
  </div>

  <div class="noiseGateContainer">
    <label for="noiseGateSlider">Noise Gate Threshold:</label>
    <input type="range" id="noiseGateSlider" min="0" max="0.1" step="0.001" value="0.02">
    <div id="noiseGateValue">0.02</div>
  </div>

  <input id="timeSlider" type="range" min="0" max="60" value="0" step="1">
</div>

<div id="pianoContainer">
  <div id="pianoAxis">
    <svg id="axisSvg" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>
  <div id="pianoRollWrapper">
    <svg id="pianoRoll" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>
</div>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const volumeLevel = document.getElementById("volumeLevel");
const volumeText = document.getElementById("volumeText");
const noiseGateSlider = document.getElementById("noiseGateSlider");
const noiseGateValue = document.getElementById("noiseGateValue");

function log(msg){ logEl.textContent += msg + "\n"; logEl.scrollTop = logEl.scrollHeight; }

window.addEventListener("error", e => log("JS Error: " + e.message + " @ " + e.filename + ":" + e.lineno));
window.addEventListener("unhandledrejection", e => log("Unhandled Promise Rejection: " + e.reason));

let audioContext, mic, analyser, highpass, workletNode;
let running = false;
let capturedNotes = [];
let noteState = new Map();
let startTime = 0;
const roll = document.getElementById("pianoRoll");
const timeSlider = document.getElementById("timeSlider");

const minMidi = 40, maxMidi = 84;
const keyHeight = 12;
const widthPerSec = 100;
let noiseThreshold = parseFloat(noiseGateSlider.value);

noiseGateSlider.oninput = () => {
  noiseThreshold = parseFloat(noiseGateSlider.value);
  noiseGateValue.textContent = noiseThreshold.toFixed(3);
  if(workletNode) workletNode.port.postMessage({type:"threshold",value:noiseThreshold});
};

function drawAxis(){
  const NS = "http://www.w3.org/2000/svg";
  const axisSvg = document.getElementById("axisSvg");
  axisSvg.innerHTML = "";
  axisSvg.setAttribute("height",(maxMidi-minMidi+1)*keyHeight);
  for(let m=maxMidi; m>=minMidi; m--){
    const y = (maxMidi-m)*keyHeight;
    const rect = document.createElementNS(NS,"rect");
    rect.setAttribute("x",0); rect.setAttribute("y",y);
    rect.setAttribute("width",60); rect.setAttribute("height",keyHeight);
    rect.setAttribute("fill", [1,3,6,8,10].includes(m%12)?"#333":"#fff");
    rect.setAttribute("stroke","#000");
    axisSvg.appendChild(rect);
    if(![1,3,6,8,10].includes(m%12)){
      const text = document.createElementNS(NS,"text");
      text.setAttribute("x",5); text.setAttribute("y",y+keyHeight-2);
      text.setAttribute("font-size","10");
      text.textContent = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][m%12]+Math.floor(m/12);
      axisSvg.appendChild(text);
    }
  }
}

function drawPianoRoll(){
  roll.innerHTML="";
  const NS="http://www.w3.org/2000/svg";
  const totalW = (parseFloat(timeSlider.max)||1)*widthPerSec + 200;
  const totalH = (maxMidi-minMidi+1)*keyHeight;
  roll.setAttribute("width",totalW);
  roll.setAttribute("height",totalH);

  let notes=[...capturedNotes];
  if(running){ for(let [m,st] of noteState){ notes.push({midi:m,start:st.start,end:audioContext.currentTime}); } }

  for(let ev of notes){
    if(!ev.end||ev.end<=ev.start) continue;
    const x = ev.start*widthPerSec;
    const w = (ev.end-ev.start)*widthPerSec;
    const y = (maxMidi-ev.midi)*keyHeight;
    const rect = document.createElementNS(NS,"rect");
    rect.setAttribute("x",x);
    rect.setAttribute("y",y);
    rect.setAttribute("width",w);
    rect.setAttribute("height",keyHeight-1);
    rect.setAttribute("fill","#4CAF50");
    roll.appendChild(rect);
  }
}

async function setup(){
  const workletCode = `
    let threshold=${noiseThreshold};
    const notesFreqs = [];
    for(let m=40;m<=84;m++){ notesFreqs[m]=440*Math.pow(2,(m-69)/12); }
    function hann(n,N){ return 0.5*(1-Math.cos(2*Math.PI*n/(N-1))); }
    class GoertzelProcessor extends AudioWorkletProcessor{
      constructor(){
        super();
        this.buf = new Float32Array(1024);
        this.i=0;
        this.hpBuf=0;
        this.alpha=2*Math.PI*70/sampleRate;
        this.port.postMessage({type:"ready"});
        this.port.onmessage = e => { if(e.data.type==="threshold") threshold=e.data.value; };
      }
      process(inputs){ 
        let input=inputs[0]; if(!input||!input[0]) return true; 
        let ch=input[0]; 
        for(let s of ch){ 
          this.hpBuf += this.alpha*(s-this.hpBuf);
          let x=this.hpBuf; 
          if(Math.abs(x)>threshold){ 
            this.buf[this.i++]=x;
            if(this.i>=this.buf.length){
              let detected=[];
              for(let m=40;m<=84;m++){
                let coeff=2*Math.cos(2*Math.PI*notesFreqs[m]/sampleRate*this.buf.length);
                let s1=0,s2=0;
                for(let j=0;j<this.buf.length;j++){
                  let win=this.buf[j]*0.5*(1-Math.cos(2*Math.PI*j/(this.buf.length-1)));
                  let s0 = win + coeff*s1 - s2;
                  s2=s1; s1=s0;
                }
                let power=s1*s1+s2*s2-coeff*s1*s2;
                if(power>0.01) detected.push(m);
              }
              if(detected.length) this.port.postMessage({type:"notes",notes:detected,time=currentTime});
              this.i=0;
            }
          }
        }
        return true;
      }
    }
    registerProcessor("goertzel-processor",GoertzelProcessor);
  `;
  const blob = new Blob([workletCode], { type: 'text/javascript' });
  const moduleURL = URL.createObjectURL(blob);
  await audioContext.audioWorklet.addModule(moduleURL);
  URL.revokeObjectURL(moduleURL);

  mic=await navigator.mediaDevices.getUserMedia({audio:true});
  highpass=audioContext.createBiquadFilter();
  highpass.type="highpass";highpass.frequency.value=70;
  analyser=audioContext.createAnalyser();
  workletNode=new AudioWorkletNode(audioContext,"goertzel-processor");
  const source=audioContext.createMediaStreamSource(mic);
  source.connect(highpass).connect(workletNode).connect(analyser);

  workletNode.port.onmessage = e => {
    let msg = e.data;
    if(msg.type==="ready") log("Worklet ready");
    if(msg.type==="notes"&&running) handleNotes(msg.notes,msg.time);
  };

  visualizeVolume();
}

function visualizeVolume(){
  const data=new Uint8Array(analyser.fftSize);
  function draw(){
    requestAnimationFrame(draw);
    analyser.getByteTimeDomainData(data);
    let sum=0;for(let v of data){let d=v-128;sum+=d*d;}
    let rms=Math.sqrt(sum/data.length)/128;
    volumeLevel.style.width = (rms*100)+"%";
    volumeText.textContent = rms.toFixed(2);
  }
  draw();
}

function handleNotes(notes,time){
  for(let m of notes){
    if(!noteState.has(m)){ noteState.set(m,{start:time}); log("NoteOn "+m); }
  }
  for(let [m,st] of [...noteState]){
    if(!notes.includes(m)){ capturedNotes.push({midi:m,start:st.start,end:time}); noteState.delete(m); log("NoteOff "+m); }
  }
  drawPianoRoll();
}

document.getElementById("startBtn").onclick = async () => {
  try {
    if (!audioContext) { audioContext = new AudioContext(); await audioContext.resume(); await setup(); }
    else if (audioContext.state==="suspended") await audioContext.resume();
    running=true; startTime=audioContext.currentTime; log("Recording started");
  } catch(e){ log("StartBtn Error: "+e.message); }
};
document.getElementById("stopBtn").onclick = () => {
  try { if(audioContext && audioContext.state==="running") audioContext.suspend(); running=false; log("Stopped"); drawPianoRoll(); }
  catch(e){ log("StopBtn Error: "+e.message); }
};
document.getElementById("exportBtn").onclick = () => { try { exportMIDI(); } catch(e){ log("ExportBtn Error: "+e.message); } };

function exportMIDI(){ /* implement MIDI export */ }

drawAxis();
</script>
</body>
</html>