<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Realtime Piano Roll Recorder</title>
  <style>
    html, body {
      margin:0; padding:0; overflow:hidden;
      font-family: Arial, sans-serif;
    }
    #controls {
      padding:8px;
      background:#f8f8f8;
      display:flex;
      flex-wrap:wrap;
      align-items:center;
    }
    button {
      margin:4px;
      padding:14px 20px;
      font-size:18px;
      border-radius:6px;
      border:1px solid #444;
      background:#f2f2f2;
    }
    button:disabled { opacity:0.5; }
    #status { margin-left:8px; font-weight:bold; }
    #pianoRollWrapper {
      position:absolute; top:70px; left:0; right:0; bottom:220px;
      overflow-x:auto; overflow-y:hidden;
      background:white;
    }
    #pianoRoll {
      height:100%;
    }
    .sliderRow { padding:8px; background:#fafafa; }
    .sliderRow label { display:inline-block; width:120px; }
    #volumeBar { width:200px; height:18px; background:#eee; display:inline-block;
      vertical-align:middle; margin-left:8px; border-radius:3px; overflow:hidden;}
    #volumeFill { height:100%; width:0; background:green; }
    #timeDisplay { margin-left:8px; }
    #log {
      font-family: monospace;
      white-space: pre-wrap;
      position:absolute; bottom:0; left:0; right:0;
      height:200px;
      overflow-y:auto;
      background:#fafafa;
      padding:8px;
      border-top:1px solid #ccc;
    }
    rect.note { stroke:black; stroke-width:1; }
  </style>
</head>
<body>
  <div id="controls">
    <button id="startBtn">‚ñ∂ Start</button>
    <button id="stopBtn" disabled>‚èπ Stop</button>
    <button id="exportBtn" disabled>üíæ Export MIDI</button>
    <span id="status">idle</span>
  </div>

  <div class="sliderRow">
    <label for="gateThreshold">Noise Gate:</label>
    <input type="range" id="gateThreshold" min="0" max="0.05" step="0.001" value="0.001">
    <span id="gateVal">0.001</span>
    <div id="volumeBar"><div id="volumeFill"></div></div>
  </div>

  <div class="sliderRow">
    <label for="timeSlider">Timeline:</label>
    <input type="range" id="timeSlider" min="0" max="0" step="0.01" value="0" style="width:300px;">
    <span id="timeDisplay">0.0s</span>
  </div>

  <div id="pianoRollWrapper">
    <svg id="pianoRoll" width="2000" height="600"></svg>
  </div>

  <pre id="log"></pre>

<script src="https://unpkg.com/midiwriter-js/dist/MidiWriter.min.js"></script>
<script>
/* -----------------------------
   Worklet processor
   ----------------------------- */
const workletSource = `
class GoertzelPitchProcessor extends AudioWorkletProcessor {
  constructor(options) {
    super();
    const opt = options.processorOptions || {};
    this.midiLow = opt.midiLow || 40;
    this.midiHigh = opt.midiHigh || 88;
    this.sampleRate = sampleRate;
    this.blockSize = opt.blockSize || 1024;
    this.gateThreshold = opt.gateThreshold || 0.001;
    this.notes = [];
    for (let midi = this.midiLow; midi <= this.midiHigh; ++midi) {
      const freq = 440 * Math.pow(2, (midi - 69)/12);
      const omega = 2 * Math.PI * (freq/this.sampleRate);
      const coeff = 2 * Math.cos(omega);
      this.notes.push({ midi, coeff, smooth: 0 });
    }
    this.buf = new Float32Array(this.blockSize);
    this.bufIndex = 0;
    this.port.onmessage = e => {
      if (e.data.type === 'setGate') this.gateThreshold = e.data.value;
    };
    this.port.postMessage({type:'ready'});
  }

  hann(n, N) { return 0.5 * (1 - Math.cos(2*Math.PI*n/(N-1))); }

  goertzel(block, coeff) {
    let s0=0,s1=0,s2=0;
    for(let i=0;i<block.length;++i){ s0=block[i]+coeff*s1-s2; s2=s1; s1=s0; }
    return s1*s1+s2*s2-coeff*s1*s2;
  }

  process(inputs) {
    const input = inputs[0];
    if (!input || input.length===0) return true;
    const ch = input[0];
    let sum=0; for(let i=0;i<ch.length;i++) sum+=ch[i]*ch[i];
    const rms=Math.sqrt(sum/ch.length);
    this.port.postMessage({type:'rms',value:rms});
    for(let i=0;i<ch.length;i++){
      this.buf[this.bufIndex++]=ch[i];
      if(this.bufIndex>=this.blockSize){
        const block=new Float32Array(this.blockSize);
        for(let j=0;j<this.blockSize;j++) block[j]=this.buf[j]*this.hann(j,this.blockSize);
        this.bufIndex=0;
        const detections=[];
        let maxE=0;
        for(let n of this.notes){
          const mag2=this.goertzel(block,n.coeff);
          n.smooth=0.7*n.smooth+0.3*Math.sqrt(mag2);
          if(n.smooth>maxE) maxE=n.smooth;
        }
        const thresh=Math.max(this.gateThreshold,maxE*0.25);
        for(let n of this.notes){ if(n.smooth>thresh) detections.push({midi:n.midi}); }
        if(detections.length>0) this.port.postMessage({type:'detections',detections,timestamp:currentTime});
      }
    }
    return true;
  }
}
registerProcessor('goertzel-pitch-processor',GoertzelPitchProcessor);
`;

/* -----------------------------
   Main thread
   ----------------------------- */
const startBtn=document.getElementById('startBtn');
const stopBtn=document.getElementById('stopBtn');
const exportBtn=document.getElementById('exportBtn');
const statusSpan=document.getElementById('status');
const logPre=document.getElementById('log');
const gateSlider=document.getElementById('gateThreshold');
const gateVal=document.getElementById('gateVal');
const volumeFill=document.getElementById('volumeFill');
const timeSlider=document.getElementById('timeSlider');
const timeDisplay=document.getElementById('timeDisplay');
const roll=document.getElementById('pianoRoll');

let audioContext=null, micStream=null, workletNode=null, highpass=null;
let noteState=new Map(), capturedNotes=[];
let rafId=null, running=false;

function logMessage(obj){
  logPre.textContent += JSON.stringify(obj)+"\\n";
  logPre.scrollTop = logPre.scrollHeight;
}

async function startAudio(){
  audioContext=new (window.AudioContext||window.webkitAudioContext)();
  const blob=new Blob([workletSource],{type:'application/javascript'});
  const url=URL.createObjectURL(blob);
  await audioContext.audioWorklet.addModule(url);
  workletNode=new AudioWorkletNode(audioContext,'goertzel-pitch-processor',
    {processorOptions:{midiLow:40,midiHigh:84,blockSize:1024,gateThreshold:parseFloat(gateSlider.value)}});
  workletNode.port.onmessage=e=>handleMessage(e.data);
  micStream=await navigator.mediaDevices.getUserMedia({audio:true});
  const src=audioContext.createMediaStreamSource(micStream);
  highpass=audioContext.createBiquadFilter();
  highpass.type="highpass"; highpass.frequency.value=70;
  src.connect(highpass).connect(workletNode).connect(audioContext.destination);
  statusSpan.textContent="running";
  startBtn.disabled=true; stopBtn.disabled=false; exportBtn.disabled=false;
  running=true;
  tickTimeline();
}

function stopAudio(){
  running=false;
  cancelAnimationFrame(rafId);
  if(audioContext){
    const t=audioContext.currentTime;
    for(let [m,st] of noteState){ if(!st.end){st.end=t; capturedNotes.push({midi:m,start:st.start,end:st.end});} }
    noteState.clear();
    audioContext.close(); audioContext=null;
  }
  if(micStream){ micStream.getTracks().forEach(tr=>tr.stop()); micStream=null; }
  statusSpan.textContent="stopped";
  startBtn.disabled=false; stopBtn.disabled=true;
  drawPianoRoll();
}

function handleMessage(msg){
  logMessage(msg);
  if(msg.type==='rms'){
    const pct=Math.min(1,msg.value/0.1);
    volumeFill.style.width=(pct*200)+"px";
  }
  if(!running) return; // ignore detections after stop
  if(msg.type==='detections'){
    handleDetections(msg.detections,msg.timestamp);
  }
}

function handleDetections(dets,t){
  const now=audioContext.currentTime;
  const detected=new Set(dets.map(d=>d.midi));
  for(let midi of detected){
    if(!noteState.has(midi)) noteState.set(midi,{start:now,lastSeen:now});
    else noteState.get(midi).lastSeen=now;
  }
  for(let [m,st] of [...noteState]){
    if(!detected.has(m) && now-st.lastSeen>0.15){
      st.end=st.lastSeen; capturedNotes.push({midi:m,start:st.start,end:st.end});
      noteState.delete(m);
    }
  }
  drawPianoRoll();
}

function drawPianoRoll(){
  roll.innerHTML="";
  const widthPerSec=100; // px per second
  const keyHeight=12;    // px per MIDI semitone
  const yOffset=0;
  const minMidi=40, maxMidi=84;
  roll.setAttribute("width",(timeSlider.max*widthPerSec+200));
  roll.setAttribute("height",(maxMidi-minMidi+1)*keyHeight);
  const notes=[...capturedNotes];
  if(running){
    for(let [m,st] of noteState){ notes.push({midi:m,start:st.start,end:audioContext.currentTime}); }
  }
  for(let ev of notes){
    const x=ev.start*widthPerSec;
    const w=(ev.end-ev.start)*widthPerSec;
    const y=(maxMidi-ev.midi)*keyHeight+yOffset;
    const rect=document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute("x",x); rect.setAttribute("y",y);
    rect.setAttribute("width",w); rect.setAttribute("height",keyHeight-1);
    rect.setAttribute("class","note");
    rect.setAttribute("fill","#4CAF50");
    roll.appendChild(rect);
  }
}

function tickTimeline(){
  if(audioContext){
    const now=audioContext.currentTime;
    timeSlider.max=now.toFixed(2);
    timeSlider.value=now.toFixed(2);
    timeDisplay.textContent=now.toFixed(2)+"s";
    drawPianoRoll();
  }
  rafId=requestAnimationFrame(tickTimeline);
}

function exportMidi(){
  if(capturedNotes.length===0){alert("No notes");return;}
  const track=new MidiWriter.Track(); track.setTempo(100);
  for(let ev of capturedNotes){
    const durSec=ev.end-ev.start; const ticks=Math.max(1,Math.round(durSec/(60/100)*128));
    track.addEvent(new MidiWriter.NoteEvent({pitch:[midiToName(ev.midi)],duration:"T"+ticks}));
  }
  const writer=new MidiWriter.Writer(track);
  const a=document.createElement("a"); a.href=writer.dataUri(); a.download="capture.mid"; a.click();
}
function midiToName(m){const names=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]; return names[m%12]+(Math.floor(m/12)-1);}

startBtn.onclick=startAudio;
stopBtn.onclick=stopAudio;
exportBtn.onclick=exportMidi;
gateSlider.oninput=()=>{ gateVal.textContent=gateSlider.value; if(workletNode) workletNode.port.postMessage({type:"setGate",value:parseFloat(gateSlider.value)}); };
</script>
</body>
</html>