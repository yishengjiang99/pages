<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Goertzel Piano Roll with MIDI Playback</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body {
    margin: 0;
    font-family: sans-serif;
    user-select: none;
    -webkit-user-select: none;
    touch-action: manipulation;
    background: #1a1a1a;
    color: #eee;
  }

  #controls {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    padding: 12px;
    background: #222;
    align-items: center;
    border-bottom: 1px solid #444;
  }

  button, input[type=range] {
    font-size: 16px;
    padding: 10px 16px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  button {
    background: #4CAF50;
    color: white;
    font-weight: bold;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }

  button:hover {
    background: #3e8e41;
    transform: translateY(-2px);
  }

  button:active {
    transform: translateY(0);
  }

  button:disabled {
    background: #666;
    cursor: not-allowed;
    transform: none;
  }

  .play-controls {
    display: flex;
    gap: 12px;
    align-items: center;
  }

  #playBtn, #pauseBtn {
    background: #2196F3;
  }

  #playBtn:hover, #pauseBtn:hover {
    background: #1976D2;
  }

  #playback-seeker-container {
    flex: 1;
    min-width: 150px;
    padding: 0 12px;
  }

  #playback-seeker {
    width: 100%;
    height: 6px;
    -webkit-appearance: none;
    background: #555;
    border-radius: 5px;
    outline: none;
    transition: background 0.2s;
    touch-action: pan-x;
  }

  #playback-seeker::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: #FF9800;
    border-radius: 50%;
    cursor: grab;
  }

  #playback-seeker::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: #FF9800;
    border-radius: 50%;
    cursor: grab;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    padding: 8px;
    background: #2a2a2a;
    border-radius: 8px;
    min-width: 160px;
  }

  .control-group label {
    font-size: 14px;
    margin-bottom: 6px;
    color: #ccc;
  }

  #volume {
    width: 150px;
    height: 20px;
    background: #555;
    position: relative;
    border-radius: 3px;
    overflow: hidden;
  }

  #volumeLevel {
    height: 100%;
    width: 0%;
    background: linear-gradient(to right, #4CAF50, #8BC34A, #CDDC39, #FFEB3B, #FFC107, #FF9800, #FF5722);
    transition: width 0.1s ease;
  }

  #volumeText {
    font-size: 12px;
    color: #fff;
    margin-top: 4px;
    text-align: center;
  }

  #noiseGateSlider {
    width: 150px;
    accent-color: #4CAF50;
  }

  #pianoContainer {
    display: flex;
    height: 600px;
    overflow: hidden;
  }

  #pianoAxis {
    width: 60px;
    background: #2a2a2a;
    border-right: 1px solid #444;
  }

  #pianoAxis svg {
    width: 60px;
    height: 100%;
    display: block;
  }

  #pianoRollWrapper {
    flex: 1;
    overflow-x: scroll;
    overflow-y: hidden;
    background: #111;
    position: relative;
  }

  #pianoRoll {
    height: 600px;
  }

  #timeIndicator {
    position: absolute;
    top: 0;
    width: 2px;
    background: #f00;
    height: 100%;
    pointer-events: none;
    z-index: 10;
  }

  .note {
    transition: fill 0.2s ease, transform 0.2s ease;
  }

  .note.active {
    fill: #2196F3;
    transform: scale(1.05);
  }

  #log {
    height: 120px;
    overflow-y: scroll;
    background: #000;
    color: #0f0;
    padding: 8px;
    font-family: monospace;
    font-size: 12px;
    white-space: pre-wrap;
    border-top: 1px solid #444;
  }

  .status {
    padding: 8px 12px;
    border-radius: 20px;
    background: #333;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #f00;
  }

  .status-dot.recording {
    background: #f00;
    animation: pulse 1s infinite;
  }

  .status-dot.ready {
    background: #4CAF50;
  }

  .status-dot.playing {
    background: #FFC107;
  }

  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.4; }
    100% { opacity: 1; }
  }

  /* Modal Styles */
  .modal {
    display: none;
    position: fixed;
    z-index: 20;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.7);
    justify-content: center;
    align-items: center;
  }
  .modal-content {
    background-color: #2a2a2a;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    width: 90%;
    max-width: 800px;
    position: relative;
    max-height: 90%;
    overflow-y: auto;
  }
  .close-btn {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
  }
  .close-btn:hover, .close-btn:focus {
    color: #fff;
    text-decoration: none;
    cursor: pointer;
  }
  #sheetMusicContainer {
    background-color: #fff;
    padding: 10px;
    border-radius: 4px;
  }
  #controls {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  padding: 6px;
  background: #222;
  align-items: center;
  border-bottom: 1px solid #444;
  font-size: 12px;
}

button, input[type=range] {
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 4px;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
}

button {
  background: #4CAF50;
  color: white;
  font-weight: 600;
  box-shadow: 0 1px 2px rgba(0,0,0,0.3);
}

button:hover {
  background: #3e8e41;
  transform: translateY(-1px);
}

button:active {
  transform: translateY(0);
}

.play-controls {
  display: flex;
  gap: 6px;
  align-items: center;
}

#playBtn, #pauseBtn {
  background: #2196F3;
}
#playBtn:hover, #pauseBtn:hover {
  background: #1976D2;
}

#playback-seeker-container {
  flex: 1;
  min-width: 80px;
  padding: 0 6px;
}

#playback-seeker {
  width: 100%;
  height: 4px;
}

#playback-seeker::-webkit-slider-thumb,
#playback-seeker::-moz-range-thumb {
  width: 12px;
  height: 12px;
}

.control-group {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 4px;
  background: #2a2a2a;
  border-radius: 4px;
  min-width: 100px;
}

.control-group label {
  font-size: 11px;
  margin-bottom: 2px;
  color: #ccc;
}

#volume {
  width: 100px;
  height: 10px;
  border-radius: 2px;
}
#volumeText {
  font-size: 10px;
  margin-top: 2px;
}

#noiseGateSlider {
  width: 100px;
}

.status {
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 11px;
  gap: 4px;
}

.status-dot {
  width: 8px;
  height: 8px;
}

#log {
  height: 80px;
  font-size: 10px;
  padding: 4px;
}
  
</style>
</head>
<body>
<div id="controls">
  <button id="recordBtn">Record</button>
  <button id="stopBtn" disabled>Stop</button>
  <button id="clearBtn">Clear</button>
  <button id="exportBtn">Export MIDI</button>
  <button id="sheetMusicBtn">Sheet Music</button>
  <div class="play-controls">
    <button id="playBtn" disabled>Play</button>
    <button id="pauseBtn" disabled>Pause</button>
  </div>

  <div class="control-group">
    <label>Volume Level</label>
    <div id="volume"><div id="volumeLevel"></div></div>
    <div id="volumeText">0.00</div>
  </div>

  <div class="control-group">
    <label for="noiseGateSlider">Noise Gate Threshold (dBFS)</label>
    <input type="range" id="noiseGateSlider" min="-100" max="-20" step="1" value="-60">
    <div id="noiseGateValue">-60</div>
  </div>

  <div class="status">
    <div id="statusDot" class="status-dot"></div>
    <span id="statusText">Ready</span>
  </div>

  <div id="playback-seeker-container">
    <input type="range" id="playback-seeker" min="0" max="100" step="0.1" value="0" disabled>
  </div>
</div>

<div id="pianoContainer">
  <div id="pianoAxis">
    <svg id="axisSvg" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>
  <div id="pianoRollWrapper">
    <div id="timeIndicator"></div>
    <svg id="pianoRoll" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>
</div>

<div id="sheetMusicModal" class="modal">
  <div class="modal-content">
    <span class="close-btn">&times;</span>
    <h3 style="color:white;">Sheet Music</h3>
    <div id="sheetMusicContainer"></div>
  </div>
</div>

<pre id="log"></pre>

<script src="https://cdnjs.cloudflare.com/ajax/libs/abcjs/6.5.2/abcjs-basic-min.js"></script>
<script>
const logEl = document.getElementById("log");
const volumeLevel = document.getElementById("volumeLevel");
const volumeText = document.getElementById("volumeText");
const noiseGateSlider = document.getElementById("noiseGateSlider");
const noiseGateValue = document.getElementById("noiseGateValue");
const recordBtn = document.getElementById("recordBtn");
const stopBtn = document.getElementById("stopBtn");
const clearBtn = document.getElementById("clearBtn");
const exportBtn = document.getElementById("exportBtn");
const sheetMusicBtn = document.getElementById("sheetMusicBtn");
const playBtn = document.getElementById("playBtn");
const pauseBtn = document.getElementById("pauseBtn");
const playbackSeeker = document.getElementById("playback-seeker");
const statusDot = document.getElementById("statusDot");
const statusText = document.getElementById("statusText");
const timeIndicator = document.getElementById("timeIndicator");
const roll = document.getElementById("pianoRoll");
const sheetMusicModal = document.getElementById("sheetMusicModal");
const sheetMusicContainer = document.getElementById("sheetMusicContainer");
const closeModalBtn = document.querySelector("#sheetMusicModal .close-btn");

// Constants
const minMidi = 40, maxMidi = 84;
const keyHeight = 12;
const widthPerSec = 100;
const NS = "http://www.w3.org/2000/svg";

// State variables
let audioContext, micSource, noiseGateNode, goertzelNode, rmsNode, synthNode;
let recording = false;
let playing = false;
let capturedNotes = [];
let noteState = new Map();
let startTime = 0;
let playbackTimeouts = [];
let playbackStartTime = 0;
let playbackPosition = 0;
let animationFrame;
let noiseThreshold = parseFloat(noiseGateSlider.value);
let dynamicThreshold = -100;

// Utility functions
function log(msg) {
  const timestamp = new Date().toLocaleTimeString();
  logEl.textContent += `[${timestamp}] ${msg}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

function updateStatus(status, state) {
  statusText.textContent = status;
  if(state === "recording") {
    statusDot.className = "status-dot recording";
  } else if(state === "playing") {
    statusDot.className = "status-dot playing";
  } else {
    statusDot.className = "status-dot ready";
  }
}

window.addEventListener("error", e => log("JS Error: " + e.message + " @ " + e.filename + ":" + e.lineno));
window.addEventListener("unhandledrejection", e => log("Unhandled Promise Rejection: " + e.reason));

noiseGateSlider.oninput = () => {
  noiseThreshold = parseFloat(noiseGateSlider.value);
  noiseGateValue.textContent = noiseThreshold.toFixed(0);
  if(noiseGateNode) {
    noiseGateNode.port.postMessage({ type: "threshold", value: noiseThreshold });
  }
};

playbackSeeker.oninput = () => {
  if (playing) {
    pause();
  }
  const seekTime = (playbackSeeker.value / 100) * (playbackSeeker.max / widthPerSec);
  timeIndicator.style.left = playbackSeeker.value + "px";
  playbackPosition = seekTime * 1000;
};

// UI drawing functions
function drawAxis(){
  const axisSvg = document.getElementById("axisSvg");
  axisSvg.innerHTML = "";
  axisSvg.setAttribute("height",(maxMidi-minMidi+1)*keyHeight);

  for(let m = maxMidi; m >= minMidi; m--){
    const y = (maxMidi - m) * keyHeight;
    const rect = document.createElementNS(NS, "rect");
    rect.setAttribute("x", 0);
    rect.setAttribute("y", y);
    rect.setAttribute("width", 60);
    rect.setAttribute("height", keyHeight);
    rect.setAttribute("fill", [1,3,6,8,10].includes(m % 12) ? "#333" : "#2a2a2a");
    rect.setAttribute("stroke", "#444");
    axisSvg.appendChild(rect);

    if(![1,3,6,8,10].includes(m % 12)){
      const text = document.createElementNS(NS, "text");
      text.setAttribute("x", 5);
      text.setAttribute("y", y + keyHeight - 2);
      text.setAttribute("font-size", "10");
      text.setAttribute("fill", "#eee");
      text.textContent = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][m % 12] + Math.floor(m / 12);
      axisSvg.appendChild(text);
    }
  }
}

function drawPianoRoll(){
  const notesToDraw = [...capturedNotes];
  if(recording) {
    for(let [m, st] of noteState) {
      notesToDraw.push({midi: m, start: st.start, end: audioContext.currentTime, velocity: st.velocity, noteId: st.noteId});
    }
  }

  let maxTime = notesToDraw.length > 0 ? Math.max(...notesToDraw.map(n => n.end || n.start)) : 0;
  const totalW = Math.max((maxTime - startTime + 5) * widthPerSec, window.innerWidth - 60);
  const totalH = (maxMidi - minMidi + 1) * keyHeight;
  roll.setAttribute("width", totalW);
  roll.setAttribute("height", totalH);
  playbackSeeker.max = totalW;

  roll.querySelectorAll(".note, .note-label").forEach(el => el.remove());

  const neededLines = Math.ceil(totalW / widthPerSec);
  const currentLines = roll.querySelectorAll("line.grid-line").length;
  if (neededLines > currentLines) {
    for (let i = currentLines; i < neededLines; i++) {
      const line = document.createElementNS(NS, "line");
      line.setAttribute("x1", i * widthPerSec);
      line.setAttribute("y1", 0);
      line.setAttribute("x2", i * widthPerSec);
      line.setAttribute("y2", totalH);
      line.setAttribute("stroke", i % 4 === 0 ? "#444" : "#333");
      line.setAttribute("stroke-width", i % 4 === 0 ? "1" : "0.5");
      line.classList.add("grid-line");
      roll.insertBefore(line, roll.firstChild);
    }
  }

  notesToDraw.forEach(ev => {
    if(!ev.end || ev.end <= ev.start) return;
    const x = (ev.start - startTime) * widthPerSec;
    const w = (ev.end - ev.start) * widthPerSec;
    const y = (maxMidi - ev.midi) * keyHeight;
    const rect = document.createElementNS(NS, "rect");
    rect.setAttribute("x", x);
    rect.setAttribute("y", y);
    rect.setAttribute("width", w);
    rect.setAttribute("height", keyHeight - 1);
    const color = `hsl(${Math.round((ev.midi - minMidi) / (maxMidi - minMidi) * 360)}, 100%, 50%)`;
    rect.setAttribute("fill", color);
    rect.setAttribute("rx", "2");
    rect.setAttribute("ry", "2");
    rect.classList.add("note");
    roll.appendChild(rect);

    if (w > 30) {
      const text = document.createElementNS(NS, "text");
      text.setAttribute("x", x + 5);
      text.setAttribute("y", y + keyHeight/2 + 3);
      text.setAttribute("font-size", "10");
      text.setAttribute("fill", "#000");
      text.textContent = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][ev.midi % 12] + Math.floor(ev.midi / 12);
      text.classList.add("note-label");
      roll.appendChild(text);
    }
  });

  const wrapper = document.getElementById('pianoRollWrapper');
  if (recording) {
    const currentTimePosition = (audioContext.currentTime - startTime) * widthPerSec;
    timeIndicator.style.left = currentTimePosition + 'px';
    if (currentTimePosition > wrapper.scrollLeft + wrapper.clientWidth - 100) {
      wrapper.scrollLeft = currentTimePosition - wrapper.clientWidth + 100;
    }
  } else if(playing) {
    const currentTimePosition = (performance.now() - playbackStartTime + playbackPosition) / 1000 * widthPerSec;
    timeIndicator.style.left = currentTimePosition + 'px';
    playbackSeeker.value = currentTimePosition;
    if (currentTimePosition > wrapper.scrollLeft + wrapper.clientWidth - 100) {
      wrapper.scrollLeft = currentTimePosition - wrapper.clientWidth + 100;
    }
    if(currentTimePosition >= playbackSeeker.max) {
      stopPlayback();
    }
  }
}

// Audio Worklet processors
const workletCode = `
    const notesFreqs = [];
    for(let m = 40; m <= 84; m++) {
      notesFreqs[m] = 440 * Math.pow(2, (m - 69) / 12);
    }

    const N = 1024;
    const hannWindow = new Float32Array(N);
    const coefficients = new Float32Array(85);

    for (let j = 0; j < N; j++) {
      hannWindow[j] = 0.5 * (1 - Math.cos(2 * Math.PI * j / (N - 1)));
    }

    for (let m = 40; m <= 84; m++) {
      coefficients[m] = 2 * Math.cos(2 * Math.PI * notesFreqs[m] / sampleRate * N);
    }

    class GoertzelProcessor extends AudioWorkletProcessor {
      constructor() {
        super();
        this.buf = new Float32Array(N);
        this.i = 0;
        this.port.onmessage = e => {
          if (e.data.type === "dynamicThreshold") this.dynamicThreshold = e.data.value;
        };
        this.dynamicThreshold = -100;
      }

      process(inputs) {
        let input = inputs[0];
        if (!input || !input[0]) return true;

        let ch = input[0];
        for (let s of ch) {
          this.buf[this.i++] = s;

          if (this.i >= N) {
            const detectedNotes = [];

            for (let m = 40; m <= 84; m++) {
              let coeff = coefficients[m];
              let s1 = 0, s2 = 0;

              for (let j = 0; j < N; j++) {
                let win = this.buf[j] * hannWindow[j];
                let s0 = win + coeff * s1 - s2;
                s2 = s1;
                s1 = s0;
              }

              let power = s1 * s1 + s2 * s2 - coeff * s1 * s2;
              let db = 10 * Math.log10(power / (N*N) + 1e-12);

              if (db > this.dynamicThreshold) {
                detectedNotes.push({midi: m, velocity: Math.min(127, Math.max(0, 100 + db))});
              }
            }

            this.port.postMessage({type: "notes", notes: detectedNotes, time: currentTime});
            this.i = 0;
          }
        }

        return true;
      }
    }

    class RMSProcessor extends AudioWorkletProcessor {
      constructor() {
        super();
      }

      process(inputs) {
        let input = inputs[0];
        if (!input || !input[0]) return true;

        let ch = input[0];
        let sum = 0;
        for (let s of ch) {
          sum += s * s;
        }
        let rms = Math.sqrt(sum / ch.length);
        this.port.postMessage({type: "rms", value: rms});
        return true;
      }
    }

    class NoiseGateProcessor extends AudioWorkletProcessor {
      constructor() {
        super();
        this.threshold = -60;
        this.attack = 0.01;
        this.release = 0.05;
        this.prevGain = 1.0;
        this.port.onmessage = e => {
          if (e.data.type === "threshold") this.threshold = e.data.value;
          if (e.data.type === "attack") this.attack = e.data.value;
          if (e.data.type === "release") this.release = e.data.value;
        };
      }

      static toDecibel(power) {
        return 10 * Math.log10(power + 1e-12);
      }

      process(inputs, outputs) {
        const input = inputs[0];
        const output = outputs[0];
        if (!input || !input[0]) return true;

        const channel = input[0];
        const out = output[0];

        const sr = sampleRate;
        const attackCoeff = Math.exp(-1 / (sr * this.attack));
        const releaseCoeff = Math.exp(-1 / (sr * this.release));

        let gain = this.prevGain;

        for (let i = 0; i < channel.length; i++) {
          const level = NoiseGateProcessor.toDecibel(channel[i] * channel[i]);
          if (level < this.threshold) {
            gain = gain * attackCoeff;
          } else {
            gain = 1 - (1 - gain) * releaseCoeff;
          }
          out[i] = channel[i] * gain;
        }

        this.prevGain = gain;
        return true;
      }
    }

    class MidiSynthProcessor extends AudioWorkletProcessor{
      constructor(){
        super();
        this.voices=[];
        this.tableSize=4096;
        this.waveTable=new Float32Array(this.tableSize);
        for(let i=0;i<this.tableSize;i++) this.waveTable[i]=Math.sin((i/this.tableSize)*2*Math.PI);

        this.port.postMessage({type:'synth-ready'});

        this.port.onmessage=(e)=>{
          const d=e.data;
          // Immediately relay message to main thread
          this.port.postMessage(d);

          if(d.type==='event'){
            const ev=d.event;
            if(ev.type==='noteOn'){
              const freq=440*Math.pow(2,(ev.note-69)/12);
              const inc=freq*this.tableSize/sampleRate;
              this.voices.push({note:ev.note,phase:0,inc,gain:(ev.velocity/127)*0.25,release:false});
            } else if(ev.type==='noteOff'){
              for(let v of this.voices) if(v.note===ev.note) v.release=true;
            }
          }
        };
      }

      process(_,outputs){
        const out=outputs[0];
        const frames=out[0].length;
        for(let i=0;i<frames;i++){
          let mix=0;
          for(let vi=this.voices.length-1;vi>=0;vi--){
            const v=this.voices[vi];
            const idx=Math.floor(v.phase)%this.tableSize;
            mix+=this.waveTable[idx]*v.gain;
            v.phase+=v.inc;
            if(v.release){ v.gain*=0.995; if(v.gain<0.001) this.voices.splice(vi,1); }
          }
          for(let ch=0;ch<out.length;ch++) out[ch][i]=mix;
        }
        return true;
      }
    }

    registerProcessor("goertzel-processor", GoertzelProcessor);
    registerProcessor("rms-processor", RMSProcessor);
    registerProcessor("noise-gate-processor", NoiseGateProcessor);
    registerProcessor('midi-synth-processor',MidiSynthProcessor);
`;

// Audio setup and processing
async function setup(){
  try {
    const blob = new Blob([workletCode], {type: "application/javascript"});
    const url = URL.createObjectURL(blob);
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    await audioContext.audioWorklet.addModule(url);

    micSource = await navigator.mediaDevices.getUserMedia({audio: true});
    const source = audioContext.createMediaStreamSource(micSource);

    synthNode = new AudioWorkletNode(audioContext, 'midi-synth-processor', { numberOfOutputs: 1, outputChannelCount: [2] });
    synthNode.connect(audioContext.destination);

    noiseGateNode = new AudioWorkletNode(audioContext, "noise-gate-processor");
    noiseGateNode.port.postMessage({ type: "threshold", value: noiseThreshold });

    goertzelNode = new AudioWorkletNode(audioContext, "goertzel-processor");
    rmsNode = new AudioWorkletNode(audioContext, "rms-processor");

    source.connect(noiseGateNode);
    noiseGateNode.connect(goertzelNode);
    noiseGateNode.connect(rmsNode);

    goertzelNode.port.onmessage = e => {
      if(e.data.type === "notes" && recording){
        handleNotes(e.data.notes, e.data.time);
      }
    };

    rmsNode.port.onmessage = e => {
      if(e.data.type === "rms"){
        let rms = e.data.value;
        let db = 20 * Math.log10(rms + 1e-12);
        dynamicThreshold = Math.max(-100, db - 10);
        goertzelNode.port.postMessage({ type: "dynamicThreshold", value: dynamicThreshold });

        let pct = Math.min(100, Math.max(0, (db + 100) / 80 * 100));
        volumeLevel.style.width = pct + "%";
        volumeText.textContent = db.toFixed(2);
      }
    };

    updateStatus("Ready", "ready");
    log("Audio engine ready.");
  } catch(e) {
    log("Error setting up audio: " + e.message);
    updateStatus("Error", "ready");
  }
}

function handleNotes(detected, time){
  const detectedMidies = detected.map(n => n.midi);

  for(let n of detected){
    if(!noteState.has(n.midi)){
      noteState.set(n.midi, {start: audioContext.currentTime, velocity: n.velocity, noteId: performance.now()});
      log(`Note on: ${n.midi} (Velocity: ${n.velocity})`);
    }
  }

  for(let [midi, st] of [...noteState]) {
    if(!detectedMidies.includes(midi)) {
      capturedNotes.push({midi: midi, start: st.start, end: audioContext.currentTime, velocity: st.velocity, noteId: st.noteId});
      noteState.delete(midi);
      log(`Note off: ${midi}`);
    }
  }
}

function startRecording(){
  if (playing) stopPlayback();
  recording = true;
  recordBtn.disabled = true;
  stopBtn.disabled = false;
  clearBtn.disabled = true;
  playBtn.disabled = true;
  pauseBtn.disabled = true;

  noteState.clear();
  startTime = audioContext.currentTime;
  updateStatus("Recording...", "recording");

  function loop(){
    drawPianoRoll();
    animationFrame = requestAnimationFrame(loop);
  }
  loop();
}

function stopRecording(){
  recording = false;
  recordBtn.disabled = false;
  stopBtn.disabled = true;
  clearBtn.disabled = false;

  for(let [m, st] of noteState) {
    capturedNotes.push({midi: m, start: st.start, end: audioContext.currentTime, velocity: st.velocity, noteId: st.noteId});
  }
  noteState.clear();
  cancelAnimationFrame(animationFrame);
  drawPianoRoll();
  updateStatus("Stopped", "ready");
  log("Recording stopped.");
  if (capturedNotes.length > 0) {
    playBtn.disabled = false;
  }
  playbackSeeker.disabled = false;
}

function clearRoll() {
  if (recording) stopRecording();
  if (playing) stopPlayback();
  capturedNotes = [];
  noteState.clear();
  drawPianoRoll();
  log("Piano roll cleared.");
  playBtn.disabled = true;
  playbackSeeker.disabled = true;
  playbackSeeker.value = 0;
  timeIndicator.style.left = "0px";
}

function startPlayback() {
  if (recording) stopRecording();
  if (playing) return;

  playing = true;
  recordBtn.disabled = true;
  stopBtn.disabled = true;
  playBtn.disabled = true;
  pauseBtn.disabled = false;
  playbackSeeker.disabled = false;

  updateStatus("Playing...", "playing");
  log("Playback started.");

  playbackStartTime = performance.now();

  const events = [];
  capturedNotes.forEach(note => {
    events.push({type: 'noteOn', time: (note.start - startTime) * 1000, note: note.midi, velocity: note.velocity});
    events.push({type: 'noteOff', time: (note.end - startTime) * 1000, note: note.midi});
  });

  events.sort((a,b) => a.time - b.time);

  playbackTimeouts = events.map(event => {
    const relativeTime = event.time - playbackPosition;
    if (relativeTime < 0) return null; // Skip events that are already passed
    return setTimeout(() => {
      synthNode.port.postMessage({ type: 'event', event });
    }, relativeTime);
  });

  function loop(){
    drawPianoRoll();
    animationFrame = requestAnimationFrame(loop);
  }
  loop();
}

function pause() {
  playing = false;
  playbackPosition += performance.now() - playbackStartTime;
  recordBtn.disabled = false;
  playBtn.disabled = false;
  pauseBtn.disabled = true;
  clearTimeouts();
  cancelAnimationFrame(animationFrame);
  updateStatus("Paused", "ready");
  log("Playback paused.");
}

function stopPlayback() {
  playing = false;
  playbackPosition = 0;
  recordBtn.disabled = false;
  playBtn.disabled = false;
  pauseBtn.disabled = true;
  clearTimeouts();
  cancelAnimationFrame(animationFrame);
  timeIndicator.style.left = "0px";
  playbackSeeker.value = 0;
  updateStatus("Stopped", "ready");
  log("Playback stopped.");
}

function clearTimeouts() {
  playbackTimeouts.forEach(id => clearTimeout(id));
  playbackTimeouts = [];
}

function exportMIDI(){
  const events = [];
  const push = arr => events.push(...arr);

  const notes = [...capturedNotes];
  push(notes.map(n => ({type:"on", time: Math.round((n.start - startTime) * 1000), midi: n.midi, velocity: n.velocity || 100})));
  push(notes.map(n => ({type:"off", time: Math.round((n.end - startTime) * 1000), midi: n.midi})));

  events.sort((a,b) => a.time - b.time);

  function encodeVLQ(val){
    const bytes=[]; let v=val;
    do{ let b=v&0x7F; v>>=7; if(bytes.length>0) b|=0x80; bytes.unshift(b);}while(v>0);
    return bytes;
  }

  const chunks=[];
  const pushBytes=(...bytes)=>chunks.push(...bytes);
  const textEncoder=new TextEncoder();

  chunks.push(...textEncoder.encode("MThd"));
  pushBytes(0,0,0,6, 0,0, 0,1, 0,96);

  const track=[];
  let lastTime=0;
  function writeEvent(time, data){
    const delta=time-lastTime;
    lastTime=time;
    track.push(...encodeVLQ(delta),...data);
  }

  events.forEach(ev=>{
    if(ev.type==="on") writeEvent(ev.time,[0x90, ev.midi, ev.velocity]);
    if(ev.type==="off") writeEvent(ev.time,[0x80, ev.midi, 64]);
  });
  writeEvent(events.length>0 ? events[events.length-1].time+200 : 0,[0xFF,0x2F,0x00]);

  const trackHeader=textEncoder.encode("MTrk");
  const trackLength=track.length;
  const lenBytes=[(trackLength>>>24)&0xFF,(trackLength>>>16)&0xFF,(trackLength>>>8)&0xFF,trackLength&0xFF];

  const midiFile=new Uint8Array([...chunks, ...trackHeader, ...lenBytes, ...track]);
  const blob=new Blob([midiFile],{type:"audio/midi"});
  const url=URL.createObjectURL(blob);

  const a=document.createElement("a");
  a.href=url;
  a.download="output.mid";
  a.click();
  URL.revokeObjectURL(url);
  log("MIDI exported.");
}

// Sheet Music Logic
const midiToAbc = {
  36: "C,,", 37: "^C,,", 38: "D,,", 39: "^D,,", 40: "E,,", 41: "F,,", 42: "^F,,", 43: "G,,", 44: "^G,,", 45: "A,,", 46: "^A,,", 47: "B,,",
  48: "C,", 49: "^C,", 50: "D,", 51: "^D,", 52: "E,", 53: "F,", 54: "^F,", 55: "G,", 56: "^G,", 57: "A,", 58: "^A,", 59: "B,",
  60: "C", 61: "^C", 62: "D", 63: "^D", 64: "E", 65: "F", 66: "^F", 67: "G", 68: "^G", 69: "A", 70: "^A", 71: "B",
  72: "c", 73: "^c", 74: "d", 75: "^d", 76: "e", 77: "f", 78: "^f", 79: "g", 80: "^g", 81: "a", 82: "^a", 83: "b",
  84: "c'", 85: "^c'", 86: "d'", 87: "^d'", 88: "e'", 89: "f'", 90: "^f'", 91: "g'", 92: "^g'", 93: "a'", 94: "^a'", 95: "b'"
};

function displaySheetMusic() {
  if(capturedNotes.length === 0) {
    alert("No notes recorded to display as sheet music.");
    return;
  }
  
  const events = [...capturedNotes].sort((a, b) => a.start - b.start);
  
  let abcString = "X:1\nT:Recorded Performance\n" +
                  "M:4/4\nL:1/8\nK:C\n";
                  
  let lastTime = startTime;
  let measureBeats = 0;
  
  events.forEach(note => {
    const duration = note.end - note.start;
    const restDuration = note.start - lastTime;
    
    if (restDuration > 0) {
      const beats = Math.round(restDuration * 2); // Assuming 1/8 note length = 0.5s
      if (beats > 0) {
        abcString += "z" + beats;
        measureBeats += beats;
      }
    }
    
    const noteBeats = Math.round(duration * 2);
    if (noteBeats > 0) {
      const abcNote = midiToAbc[note.midi] || "c";
      abcString += abcNote + noteBeats;
      measureBeats += noteBeats;
    }
    
    while(measureBeats >= 8) {
      abcString += "|";
      measureBeats -= 8;
    }
    
    lastTime = note.end;
  });
  
  if (measureBeats > 0) {
      while(measureBeats < 8) {
          abcString += "z";
          measureBeats++;
      }
      abcString += "|";
  }

  log("Generating sheet music with ABC Notation:\n" + abcString);
  
  ABCJS.renderAbc(sheetMusicContainer, abcString, {staffwidth: 750});
  sheetMusicModal.style.display = "flex";
}

// Event listeners
recordBtn.onclick = async () => {
  if(!audioContext){
    await setup();
  }
  startRecording();
};

stopBtn.onclick = () => stopRecording();
clearBtn.onclick = () => clearRoll();
exportBtn.onclick = () => exportMIDI();
sheetMusicBtn.onclick = () => displaySheetMusic();
playBtn.onclick = () => startPlayback();
pauseBtn.onclick = () => pause();

closeModalBtn.onclick = () => {
  sheetMusicModal.style.display = "none";
};

window.onclick = (event) => {
  if (event.target === sheetMusicModal) {
    sheetMusicModal.style.display = "none";
  }
};

// Initial setup
drawAxis();
updateStatus("Ready", "ready");
</script>
</body>
</html>
