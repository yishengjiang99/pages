<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Realtime Pitch ‚Üí MIDI ‚Üí VexFlow</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 12px; }
    #controls { margin-bottom: 12px; }
    button {
      margin: 6px;
      padding: 14px 20px;
      font-size: 18px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #f2f2f2;
    }
    button:disabled { opacity: 0.5; }
    #status { margin-left: 8px; font-weight: bold; }
    #sheet { border:1px solid #ddd; padding: 8px; min-height: 160px; margin-top:12px;}
    .sliderRow { margin: 12px 0; }
    .sliderRow label { display:inline-block; width: 120px; }
    #volumeBar { width:200px; height:18px; background:#eee; display:inline-block; vertical-align:middle; margin-left:8px; border-radius:3px; overflow:hidden;}
    #volumeFill { height:100%; width:0; background:green; }
    #timeDisplay { margin-left:8px; }
    #log {
      font-family: monospace;
      white-space: pre-wrap;
      margin-top: 16px;
      max-height: 200px;
      overflow-y: auto;
      background:#fafafa;
      padding:8px;
      border-radius:6px;
      border:1px solid #ddd;
    }
  </style>
  <script src="https://unpkg.com/vexflow/releases/vexflow-min.js"></script>
  <script src="https://unpkg.com/midiwriter-js/dist/MidiWriter.min.js"></script>
</head>
<body>
  <h2>Realtime polyphonic pitch ‚Üí MIDI ‚Üí VexFlow</h2>
  <div id="controls">
    <button id="startBtn">‚ñ∂ Start</button>
    <button id="stopBtn" disabled>‚èπ Stop</button>
    <button id="exportBtn" disabled>üíæ Export MIDI</button>
    <span id="status">idle</span>
  </div>

  <div class="sliderRow">
    <label for="gateThreshold">Noise Gate:</label>
    <input type="range" id="gateThreshold" min="0" max="0.05" step="0.001" value="0.001">
    <span id="gateVal">0.001</span>
    <div id="volumeBar"><div id="volumeFill"></div></div>
  </div>

  <div class="sliderRow">
    <label for="timeSlider">Timeline:</label>
    <input type="range" id="timeSlider" min="0" max="0" step="0.01" value="0" style="width:300px;">
    <span id="timeDisplay">0.0s</span>
  </div>

  <div id="sheet"></div>
  <pre id="log"></pre>

<script>
/* -----------------------------
   Worklet processor
   ----------------------------- */
const workletSource = `
class GoertzelPitchProcessor extends AudioWorkletProcessor {
  constructor(options) {
    super();
    const opt = options.processorOptions || {};
    this.midiLow = opt.midiLow || 40;
    this.midiHigh = opt.midiHigh || 88;
    this.sampleRate = sampleRate;
    this.blockSize = opt.blockSize || 1024;
    this.gateThreshold = opt.gateThreshold || 0.001;
    this.notes = [];
    for (let midi = this.midiLow; midi <= this.midiHigh; ++midi) {
      const freq = 440 * Math.pow(2, (midi - 69)/12);
      const omega = 2 * Math.PI * (freq/this.sampleRate);
      const coeff = 2 * Math.cos(omega);
      this.notes.push({ midi, coeff, smooth: 0 });
    }
    this.buf = new Float32Array(this.blockSize);
    this.bufIndex = 0;
    this.port.onmessage = e => {
      if (e.data.type === 'setGate') this.gateThreshold = e.data.value;
    };
    this.port.postMessage({type:'ready'});
  }

  hann(n, N) { return 0.5 * (1 - Math.cos(2*Math.PI*n/(N-1))); }

  goertzel(block, coeff) {
    let s0=0,s1=0,s2=0;
    for(let i=0;i<block.length;++i){ s0=block[i]+coeff*s1-s2; s2=s1; s1=s0; }
    return s1*s1+s2*s2-coeff*s1*s2;
  }

  process(inputs) {
    const input = inputs[0];
    if (!input || input.length===0) return true;
    const ch = input[0];
    let sum=0; for(let i=0;i<ch.length;i++) sum+=ch[i]*ch[i];
    const rms=Math.sqrt(sum/ch.length);
    this.port.postMessage({type:'rms',value:rms});
    for(let i=0;i<ch.length;i++){
      this.buf[this.bufIndex++]=ch[i];
      if(this.bufIndex>=this.blockSize){
        const block=new Float32Array(this.blockSize);
        for(let j=0;j<this.blockSize;j++) block[j]=this.buf[j]*this.hann(j,this.blockSize);
        this.bufIndex=0;
        const detections=[];
        let maxE=0;
        for(let n of this.notes){
          const mag2=this.goertzel(block,n.coeff);
          n.smooth=0.7*n.smooth+0.3*Math.sqrt(mag2);
          if(n.smooth>maxE) maxE=n.smooth;
        }
        const thresh=Math.max(this.gateThreshold,maxE*0.25);
        for(let n of this.notes){ if(n.smooth>thresh) detections.push({midi:n.midi}); }
        if(detections.length>0) this.port.postMessage({type:'detections',detections,timestamp:currentTime});
      }
    }
    return true;
  }
}
registerProcessor('goertzel-pitch-processor',GoertzelPitchProcessor);
`;

/* -----------------------------
   Main thread
   ----------------------------- */
const startBtn=document.getElementById('startBtn');
const stopBtn=document.getElementById('stopBtn');
const exportBtn=document.getElementById('exportBtn');
const statusSpan=document.getElementById('status');
const logPre=document.getElementById('log');
const sheetDiv=document.getElementById('sheet');
const gateSlider=document.getElementById('gateThreshold');
const gateVal=document.getElementById('gateVal');
const volumeFill=document.getElementById('volumeFill');
const timeSlider=document.getElementById('timeSlider');
const timeDisplay=document.getElementById('timeDisplay');

let audioContext=null, micStream=null, workletNode=null;
let noteState=new Map(), capturedNotes=[];
let rafId=null;

function logMessage(obj){
  logPre.textContent += JSON.stringify(obj)+"\\n";
  logPre.scrollTop = logPre.scrollHeight;
}

async function startAudio(){
  audioContext=new (window.AudioContext||window.webkitAudioContext)();
  const blob=new Blob([workletSource],{type:'application/javascript'});
  const url=URL.createObjectURL(blob);
  await audioContext.audioWorklet.addModule(url);
  workletNode=new AudioWorkletNode(audioContext,'goertzel-pitch-processor',
    {processorOptions:{midiLow:40,midiHigh:84,blockSize:1024,gateThreshold:parseFloat(gateSlider.value)}});
  workletNode.port.onmessage=e=>handleMessage(e.data);
  micStream=await navigator.mediaDevices.getUserMedia({audio:true});
  audioContext.createMediaStreamSource(micStream).connect(workletNode).connect(audioContext.destination);
  statusSpan.textContent="running";
  startBtn.disabled=true; stopBtn.disabled=false; exportBtn.disabled=false;
  tickTimeline();
}

function stopAudio(){
  cancelAnimationFrame(rafId);
  if(audioContext){
    const t=audioContext.currentTime;
    for(let [m,st] of noteState){ if(!st.end){st.end=t; capturedNotes.push({midi:m,start:st.start,end:st.end});} }
    noteState.clear();
    audioContext.close(); audioContext=null;
  }
  if(micStream){ micStream.getTracks().forEach(tr=>tr.stop()); micStream=null; }
  statusSpan.textContent="stopped";
  startBtn.disabled=false; stopBtn.disabled=true;
  renderScore();
}

function handleMessage(msg){
  logMessage(msg);
  if(msg.type==='rms'){
    const pct=Math.min(1,msg.value/0.1);
    volumeFill.style.width=(pct*200)+"px";
  }
  if(msg.type==='detections'){
    handleDetections(msg.detections,msg.timestamp);
  }
}

function handleDetections(dets,t){
  const now=audioContext.currentTime;
  const detected=new Set(dets.map(d=>d.midi));
  for(let midi of detected){
    if(!noteState.has(midi)) noteState.set(midi,{start:now,lastSeen:now});
    else noteState.get(midi).lastSeen=now;
  }
  for(let [m,st] of [...noteState]){
    if(!detected.has(m) && now-st.lastSeen>0.15){
      st.end=st.lastSeen; capturedNotes.push({midi:m,start:st.start,end:st.end});
      noteState.delete(m);
    }
  }
  renderScore();
}

function renderScore(){
  sheetDiv.innerHTML="";
  const VF=Vex.Flow;
  const renderer=new VF.Renderer(sheetDiv,VF.Renderer.Backends.SVG);
  renderer.resize(800,200);
  const context=renderer.getContext();
  const stave=new VF.Stave(10,10,760).addClef("treble").addTimeSignature("4/4");
  stave.setContext(context).draw();
  const events=[...capturedNotes];
  for(let [m,st] of noteState){ events.push({midi:m,start:st.start,end:audioContext?audioContext.currentTime:st.start}); }
  if(events.length===0){
    VF.Formatter.FormatAndDraw(context,stave,[new VF.StaveNote({keys:["b/4"],duration:"w"})]);
    return;
  }
  const vfNotes=[];
  for(let ev of events){
    const names=["c","c#","d","d#","e","f","f#","g","g#","a","a#","b"];
    const nm=names[ev.midi%12]; const oct=Math.floor(ev.midi/12)-1;
    const vfKey=nm+"/"+oct;
    const note=new VF.StaveNote({keys:[vfKey],duration:"q"});
    if(vfKey.includes("#")) note.addAccidental(0,new VF.Accidental("#"));
    vfNotes.push(note);
  }
  const voice=new VF.Voice({num_beats:4,beat_value:4});
  voice.addTickables(vfNotes);
  new VF.Formatter().joinVoices([voice]).format([voice],700);
  voice.draw(context,stave);
}

function tickTimeline(){
  if(audioContext){
    const now=audioContext.currentTime;
    timeSlider.max=now.toFixed(2);
    timeSlider.value=now.toFixed(2);
    timeDisplay.textContent=now.toFixed(2)+"s";
  }
  rafId=requestAnimationFrame(tickTimeline);
}

function exportMidi(){
  if(capturedNotes.length===0){alert("No notes");return;}
  const track=new MidiWriter.Track(); track.setTempo(100);
  for(let ev of capturedNotes){
    const durSec=ev.end-ev.start; const ticks=Math.max(1,Math.round(durSec/(60/100)*128));
    track.addEvent(new MidiWriter.NoteEvent({pitch:[midiToName(ev.midi)],duration:"T"+ticks}));
  }
  const writer=new MidiWriter.Writer(track);
  const a=document.createElement("a"); a.href=writer.dataUri(); a.download="capture.mid"; a.click();
}
function midiToName(m){const names=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]; return names[m%12]+(Math.floor(m/12)-1);}

startBtn.onclick=startAudio;
stopBtn.onclick=stopAudio;
exportBtn.onclick=exportMidi;
gateSlider.oninput=()=>{ gateVal.textContent=gateSlider.value; if(workletNode) workletNode.port.postMessage({type:"setGate",value:parseFloat(gateSlider.value)}); };
</script>
</body>
</html>