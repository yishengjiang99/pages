<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI to SVG Piano Roll</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            touch-action: none;
        }
        #container {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
        }
        #midiFile {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }
        #metadata, #legend {
            width: 100%;
            padding: 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            margin-bottom: 10px;
            font-size: 14px;
        }
        #legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 20px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border: 1px solid #000;
        }
        #pianoRoll {
            width: 100%;
            height: 640px;
            border: 1px solid black;
            touch-action: none;
        }
        @media (max-width: 600px) {
            #pianoRoll {
                height: 400px;
            }
            #metadata, #legend {
                font-size: 12px;
            }
            .legend-item {
                margin-right: 15px;
            }
            .legend-color {
                width: 15px;
                height: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <input type="file" id="midiFile" accept=".mid,.midi">
        <div id="metadata"></div>
        <div id="legend"></div>
        <svg id="pianoRoll"></svg>
    </div>

    <script>
        const GM_INSTRUMENTS = [
            "Acoustic Grand Piano", "Bright Acoustic Piano", "Electric Grand Piano", "Honky-tonk Piano",
            "Electric Piano 1", "Electric Piano 2", "Harpsichord", "Clavi", "Celesta", "Glockenspiel",
            "Music Box", "Vibraphone", "Marimba", "Xylophone", "Tubular Bells", "Dulcimer",
            "Drawbar Organ", "Percussive Organ", "Rock Organ", "Church Organ", "Reed Organ",
            "Accordion", "Harmonica", "Tango Accordion", "Acoustic Guitar (nylon)", "Acoustic Guitar (steel)",
            "Electric Guitar (jazz)", "Electric Guitar (clean)", "Electric Guitar (muted)", "Overdriven Guitar",
            "Distortion Guitar", "Guitar harmonics", "Acoustic Bass", "Electric Bass (finger)",
            "Electric Bass (pick)", "Fretless Bass", "Slap Bass 1", "Slap Bass 2", "Synth Bass 1",
            "Synth Bass 2", "Violin", "Viola", "Cello", "Contrabass", "Tremolo Strings",
            "Pizzicato Strings", "Orchestral Harp", "Timpani", "String Ensemble 1", "String Ensemble 2",
            "SynthStrings 1", "SynthStrings 2", "Choir Aahs", "Voice Oohs", "Synth Voice",
            "Orchestra Hit", "Trumpet", "Trombone", "Tuba", "Muted Trumpet", "French Horn",
            "Brass Section", "SynthBrass 1", "SynthBrass 2", "Soprano Sax", "Alto Sax",
            "Tenor Sax", "Baritone Sax", "Oboe", "English Horn", "Bassoon", "Clarinet",
            "Piccolo", "Flute", "Recorder", "Pan Flute", "Blown Bottle", "Shakuhachi",
            "Whistle", "Ocarina", "Lead 1 (square)", "Lead 2 (sawtooth)", "Lead 3 (calliope)",
            "Lead 4 (chiff)", "Lead 5 (charang)", "Lead 6 (voice)", "Lead 7 (fifths)",
            "Lead 8 (bass + lead)", "Pad 1 (new age)", "Pad 2 (warm)", "Pad 3 (polysynth)",
            "Pad 4 (choir)", "Pad 5 (bowed)", "Pad 6 (metallic)", "Pad 7 (halo)", "Pad 8 (sweep)",
            "FX 1 (rain)", "FX 2 (soundtrack)", "FX 3 (crystal)", "FX 4 (atmosphere)",
            "FX 5 (brightness)", "FX 6 (goblins)", "FX 7 (echoes)", "FX 8 (sci-fi)",
            "Sitar", "Banjo", "Shamisen", "Koto", "Kalimba", "Bag pipe", "Fiddle", "Shanai",
            "Tinkle Bell", "Agogo", "Steel Drums", "Woodblock", "Taiko Drum", "Melodic Tom",
            "Synth Drum", "Reverse Cymbal", "Guitar Fret Noise", "Breath Noise", "Seashore",
            "Bird Tweet", "Telephone Ring", "Helicopter", "Applause", "Gunshot"
        ];

        let transform = { x: 0, y: 0, scale: 1 };
        let isDragging = false;
        let startPoint = { x: 0, y: 0 };
        let startTransform = { x: 0, y: 0 };
        let lastPinchDistance = null;

        const svg = document.getElementById('pianoRoll');
        const container = document.getElementById('container');
        const metadataDiv = document.getElementById('metadata');
        const legendDiv = document.getElementById('legend');

        function resizeSvg() {
            const width = container.clientWidth;
            svg.setAttribute('width', width);
            drawPianoRoll(currentMidi);
        }

        window.addEventListener('resize', resizeSvg);

        svg.addEventListener('mousedown', startDrag);
        svg.addEventListener('mousemove', drag);
        svg.addEventListener('mouseup', endDrag);
        svg.addEventListener('mouseleave', endDrag);
        svg.addEventListener('wheel', zoom);
        svg.addEventListener('touchstart', handleTouch);
        svg.addEventListener('touchmove', handleTouch);
        svg.addEventListener('touchend', endDrag);

        function startDrag(e) {
            isDragging = true;
            const point = getEventPoint(e);
            startPoint = point;
            startTransform = { ...transform };
        }

        function drag(e) {
            if (!isDragging) return;
            e.preventDefault();
            const point = getEventPoint(e);
            const width = container.clientWidth;
            const noteHeight = 5;
            const height = 128 * noteHeight;

            let newX = startTransform.x + (point.x - startPoint.x);
            let newY = startTransform.y + (point.y - startPoint.y);

            const minX = -width * (transform.scale - 1);
            const maxX = 0;
            const minY = -height * (transform.scale - 1);
            const maxY = 0;

            transform.x = Math.max(minX, Math.min(newX, maxX));
            transform.y = Math.max(minY, Math.min(newY, maxY));
            updateView();
        }

        function endDrag() {
            isDragging = false;
            lastPinchDistance = null;
        }

        function zoom(e) {
            e.preventDefault();
            const point = getEventPoint(e);
            const scaleChange = e.deltaY > 0 ? 0.9 : 1.1;
            applyZoom(point, scaleChange);
        }

        function handleTouch(e) {
            e.preventDefault();
            const touches = e.touches;
            if (touches.length === 1) {
                const point = { x: touches[0].clientX, y: touches[0].clientY };
                if (!isDragging) {
                    isDragging = true;
                    startPoint = point;
                    startTransform = { ...transform };
                } else {
                    const width = container.clientWidth;
                    const noteHeight = 5;
                    const height = 128 * noteHeight;

                    let newX = startTransform.x + (point.x - startPoint.x);
                    let newY = startTransform.y + (point.y - startPoint.y);

                    const minX = -width * (transform.scale - 1);
                    const maxX = 0;
                    const minY = -height * (transform.scale - 1);
                    const maxY = 0;

                    transform.x = Math.max(minX, Math.min(newX, maxX));
                    transform.y = Math.max(minY, Math.min(newY, maxY));
                    updateView();
                }
            } else if (touches.length === 2) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const midPoint = {
                    x: (touches[0].clientX + touches[1].clientX) / 2,
                    y: (touches[0].clientY + touches[1].clientY) / 2
                };

                if (lastPinchDistance !== null) {
                    const scaleChange = distance / lastPinchDistance;
                    applyZoom(midPoint, scaleChange);
                }
                lastPinchDistance = distance;
            }
        }

        function applyZoom(point, scaleChange) {
            const width = container.clientWidth;
            const noteHeight = 5;
            const height = 128 * noteHeight;

            const oldScale = transform.scale;
            const newScale = Math.max(0.5, Math.min(transform.scale * scaleChange, 5));
            const scaleRatio = newScale / oldScale;

            let newX = point.x - scaleRatio * (point.x - transform.x);
            let newY = point.y - scaleRatio * (point.y - transform.y);

            const minX = -width * (newScale - 1);
            const maxX = 0;
            const minY = -height * (newScale - 1);
            const maxY = 0;

            transform.x = Math.max(minX, Math.min(newX, maxX));
            transform.y = Math.max(minY, Math.min(newY, maxY));
            transform.scale = newScale;
            updateView();
        }

        function getEventPoint(e) {
            const rect = svg.getBoundingClientRect();
            return {
                x: (e.clientX || e.touches?.[0]?.clientX) - rect.left,
                y: (e.clientY || e.touches?.[0]?.clientY) - rect.top
            };
        }

        function updateView() {
            svg.querySelector('g').setAttribute('transform',
                `translate(${transform.x}, ${transform.y}) scale(${transform.scale})`
            );
        }

        let currentMidi = null;

        document.getElementById('midiFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                currentMidi = parseMidi(arrayBuffer);
                transform = { x: 0, y: 0, scale: 1 };
                resizeSvg();
            };
            reader.readAsArrayBuffer(file);
        });

        function parseMidi(arrayBuffer) {
            const data = new Uint8Array(arrayBuffer);
            const view = new DataView(arrayBuffer);
            let pos = 0;

            if (String.fromCharCode(data[pos++], data[pos++], data[pos++], data[pos++]) !== 'MThd') {
                throw new Error('Not a valid MIDI file');
            }
            const headerLen = view.getUint32(pos); pos += 4;
            const format = view.getUint16(pos); pos += 2;
            const ntracks = view.getUint16(pos); pos += 2;
            const division = view.getUint16(pos); pos += 2;

            const tracks = [];
            const trackInstruments = Array(ntracks).fill().map(() => null); // Store latest program number per track

            for (let i = 0; i < ntracks; i++) {
                if (String.fromCharCode(data[pos++], data[pos++], data[pos++], data[pos++]) !== 'MTrk') {
                    throw new Error('Invalid track header');
                }
                const trackLen = view.getUint32(pos); pos += 4;
                const trackEnd = pos + trackLen;
                const events = [];
                let time = 0;
                let lastStatus = 0;

                while (pos < trackEnd) {
                    let delta = 0;
                    while (true) {
                        const byte = data[pos++];
                        delta = (delta << 7) + (byte & 0x7F);
                        if (!(byte & 0x80)) break;
                    }
                    time += delta;

                    let status = data[pos++];
                    if (status < 0x80) {
                        pos--;
                        status = lastStatus;
                    } else {
                        lastStatus = status;
                    }

                    const type = status >> 4;
                    const channel = status & 0x0F;

                    if (type === 0x8 || type === 0x9) {
                        const note = data[pos++];
                        const velocity = data[pos++];
                        events.push({
                            time,
                            type: type === 0x9 ? (velocity > 0 ? 'noteOn' : 'noteOff') : 'noteOff',
                            note,
                            velocity,
                            channel,
                            track: i
                        });
                    } else if (type === 0xC) { // Program change
                        const program = data[pos++];
                        trackInstruments[i] = program; // Store latest program number
                        events.push({ time, type: 'program', program, channel });
                    } else if (type === 0xA) {
                        pos += 2;
                    } else if (type === 0xB) {
                        pos += 2;
                    } else if (type === 0xD) {
                        pos += 1;
                    } else if (type === 0xE) {
                        pos += 2;
                    } else if (status === 0xFF) {
                        const metaType = data[pos++];
                        let len = 0;
                        while (true) {
                            const byte = data[pos++];
                            len = (len << 7) + (byte & 0x7F);
                            if (!(byte & 0x80)) break;
                        }
                        if (metaType === 0x51) {
                            const uspq = (data[pos] << 16) | (data[pos + 1] << 8) | data[pos + 2];
                            events.push({ time, type: 'tempo', uspq });
                        }
                        pos += len;
                    } else if (status === 0xF0 || status === 0xF7) {
                        let len = 0;
                        while (true) {
                            const byte = data[pos++];
                            len = (len << 7) + (byte & 0x7F);
                            if (!(byte & 0x80)) break;
                        }
                        pos += len;
                    }
                }
                tracks.push(events);
            }

            const noteEvents = [];
            let tempos = [{ tick: 0, uspq: 500000 }];
            tracks.forEach(track => {
                track.forEach(ev => {
                    if (ev.type === 'noteOn' || ev.type === 'noteOff') {
                        noteEvents.push(ev);
                    } else if (ev.type === 'tempo') {
                        tempos.push({ tick: ev.time, uspq: ev.uspq });
                    }
                });
            });

            tempos.sort((a, b) => a.tick - b.tick);
            noteEvents.sort((a, b) => a.time - b.time);

            const notesByTrack = Array(ntracks).fill().map(() => []);
            const activeNotes = new Map();
            noteEvents.forEach(ev => {
                const key = (ev.track * 128 * 16) + (ev.channel * 128) + ev.note;
                if (ev.type === 'noteOn') {
                    activeNotes.set(key, { start: ev.time, velocity: ev.velocity });
                } else if (ev.type === 'noteOff') {
                    if (activeNotes.has(key)) {
                        const { start, velocity } = activeNotes.get(key);
                        notesByTrack[ev.track].push({ note: ev.note, start, end: ev.time, velocity, channel: ev.channel });
                        activeNotes.delete(key);
                    }
                }
            });

            let maxTick = 0;
            if (noteEvents.length > 0) {
                maxTick = Math.max(...noteEvents.map(e => e.time));
            }

            return { division, format, ntracks, tracks, notesByTrack, tempos, maxTick, trackInstruments };
        }

        function tickToSeconds(tick, tempos, ppq) {
            let seconds = 0;
            let lastTick = 0;
            let currentUspq = 500000;
            let i = 0;
            while (i < tempos.length && tempos[i].tick <= tick) {
                seconds += (tempos[i].tick - lastTick) * currentUspq / 1000000 / ppq;
                currentUspq = tempos[i].uspq;
                lastTick = tempos[i].tick;
                i++;
            }
            seconds += (tick - lastTick) * currentUspq / 1000000 / ppq;
            return seconds;
        }

        function drawPianoRoll(midi) {
            if (!midi) return;

            const svg = document.getElementById('pianoRoll');
            svg.innerHTML = '';
            metadataDiv.innerHTML = '';
            legendDiv.innerHTML = '';

            if (midi.notesByTrack.every(track => track.length === 0)) return;

            const duration = tickToSeconds(midi.maxTick, midi.tempos, midi.division);
            metadataDiv.innerHTML = `
                Format: ${midi.format}<br>
                Tracks: ${midi.ntracks}<br>
                Division: ${midi.division} PPQ<br>
                Duration: ${duration.toFixed(2)} seconds
            `;

            const width = container.clientWidth;
            const noteHeight = 5;
            const svgHeight = 128 * noteHeight;
            svg.setAttribute('height', svgHeight);

            const maxSec = tickToSeconds(midi.maxTick, midi.tempos, midi.division);
            const pixelPerSec = maxSec > 0 ? width / maxSec : 0;

            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svg.appendChild(g);

            for (let i = 0; i < 128; i++) {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const y = i * noteHeight;
                rect.setAttribute('x', 0);
                rect.setAttribute('y', y);
                rect.setAttribute('width', width);
                rect.setAttribute('height', noteHeight);
                rect.setAttribute('fill', i % 2 === 0 ? '#e0e0e0' : '#c0c0c0');
                g.appendChild(rect);
            }

            const trackColors = [
                'rgba(0, 0, 255, %a)',
                'rgba(255, 0, 0, %a)',
                'rgba(0, 128, 0, %a)',
                'rgba(255, 165, 0, %a)',
                'rgba(128, 0, 128, %a)',
                'rgba(0, 128, 128, %a)'
            ];

            // Draw legend
            midi.notesByTrack.forEach((trackNotes, trackIndex) => {
                if (trackNotes.length === 0) return;
                const program = midi.trackInstruments[trackIndex];
                const instrumentName = program !== null && program >= 0 && program < GM_INSTRUMENTS.length
                    ? GM_INSTRUMENTS[program]
                    : 'Unknown Instrument';
                const color = trackColors[trackIndex % trackColors.length].replace('%a', '1');
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background-color: ${color};"></div>
                    Track ${trackIndex + 1}: ${instrumentName}
                `;
                legendDiv.appendChild(item);
            });

            midi.notesByTrack.forEach((trackNotes, trackIndex) => {
                const color = trackColors[trackIndex % trackColors.length];
                trackNotes.forEach(note => {
                    const startSec = tickToSeconds(note.start, midi.tempos, midi.division);
                    const endSec = tickToSeconds(note.end, midi.tempos, midi.division);
                    const durationSec = endSec - startSec;

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    const x = startSec * pixelPerSec;
                    const rectWidth = durationSec * pixelPerSec;
                    const y = (127 - note.note) * noteHeight;
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', y);
                    rect.setAttribute('width', rectWidth);
                    rect.setAttribute('height', noteHeight);
                    rect.setAttribute('fill', color.replace('%a', note.velocity / 127));
                    g.appendChild(rect);
                });
            });

            updateView();
        }

        resizeSvg();
    </script>
</body>
</html>
