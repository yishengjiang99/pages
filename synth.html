<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>MIDI Synth Iframe</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; padding: 1.5rem; }
.controls { display:flex; gap:0.5rem; flex-wrap:wrap; margin-bottom:1rem; }
#rms,#voices { font-weight:bold; margin-bottom:0.5rem; }
pre { border:1px solid #ddd; padding:0.5rem; background:#fafafa; font-family:monospace; font-size:0.9rem; overflow:auto; max-height:150px; }
button { padding:0.4rem 0.7rem; font-size:0.95rem; }
</style>
</head>
<body>

<div class="controls">
  <button id="startBtn">Init Audio</button>
</div>

<div id="rms">RMS: 0.0</div>
<div id="voices">Active voices: 0</div>
<pre id="log">Log:</pre>
<pre id="events">MIDI Events:</pre>

<script>
// ---------------- Worklet code ----------------
const workletCode = `
class MidiSynthProcessor extends AudioWorkletProcessor{
  constructor(){
    super();
    this.voices=[];
    this.tableSize=4096;
    this.waveTable=new Float32Array(this.tableSize);
    for(let i=0;i<this.tableSize;i++) this.waveTable[i]=Math.sin((i/this.tableSize)*2*Math.PI);

    this.port.postMessage({type:'ready'});

    this.port.onmessage=(e)=>{
      const d=e.data;
      // Immediately relay message to main thread
      this.port.postMessage(d);

      if(d.type==='event'){
        const ev=d.event;
        if(ev.type==='noteOn'){
          const freq=440*Math.pow(2,(ev.note-69)/12);
          const inc=freq*this.tableSize/sampleRate;
          this.voices.push({note:ev.note,phase:0,inc,gain:(ev.velocity/127)*0.25,release:false});
        } else if(ev.type==='noteOff'){
          for(let v of this.voices) if(v.note===ev.note) v.release=true;
        }
      }
    };
  }

  process(_,outputs){
    const out=outputs[0];
    let sumSquares=0;
    const frames=out[0].length;
    for(let i=0;i<frames;i++){
      let mix=0;
      for(let vi=this.voices.length-1;vi>=0;vi--){
        const v=this.voices[vi];
        const idx=Math.floor(v.phase)%this.tableSize;
        mix+=this.waveTable[idx]*v.gain;
        v.phase+=v.inc;
        if(v.release){ v.gain*=0.995; if(v.gain<0.001) this.voices.splice(vi,1); }
      }
      sumSquares+=mix*mix;
      for(let ch=0;ch<out.length;ch++) out[ch][i]=mix;
    }
    const rms=Math.sqrt(sumSquares/frames);
    this.port.postMessage({type:'rms',value:rms,voices:this.voices.length});
    return true;
  }
}
registerProcessor('midi-synth-processor',MidiSynthProcessor);
`;

// ---------------- Main Thread ----------------
const logEl=document.getElementById('log');
const eventsEl=document.getElementById('events');
const rmsEl=document.getElementById('rms');
const voicesEl=document.getElementById('voices');

function log(msg){ logEl.textContent+='\n'+msg; logEl.scrollTop=logEl.scrollHeight; }

let audioCtx=null, workletNode=null;

document.getElementById('startBtn').onclick = async () => {
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const url = URL.createObjectURL(new Blob([workletCode], { type: 'application/javascript' }));
  await audioCtx.audioWorklet.addModule(url);

  workletNode = new AudioWorkletNode(audioCtx, 'midi-synth-processor', { numberOfOutputs: 1, outputChannelCount: [2] });
  workletNode.connect(audioCtx.destination);

  workletNode.port.onmessage = (e) => {
    const d = e.data;
    if(d.type === 'ready'){
      log('Worklet ready');
    } else if(d.type === 'rms'){
      rmsEl.textContent = 'RMS: ' + d.value.toFixed(4);
      voicesEl.textContent = 'Active voices: ' + d.voices;
    } else if(d.type === 'event'){
      eventsEl.textContent += JSON.stringify(d.event) + '\n';
      eventsEl.scrollTop = eventsEl.scrollHeight;
    }
  };

  if(audioCtx.state === 'suspended') await audioCtx.resume();
  log('Audio initialized');
};

window.addEventListener('message', (e) => {
  if (e.data.type === 'midiEvent' && workletNode) {
    workletNode.port.postMessage({type: 'event', event: e.data.event});
  }
});
</script>

</body>
</html>