<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Remove and Replace Text in Image Using OCR</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 2vw;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      background-color: #f4f4f4;
    }
    h1 {
      font-size: clamp(1.5rem, 5vw, 2rem);
      margin: 1rem 0;
    }
    p {
      font-size: clamp(0.9rem, 3vw, 1.1rem);
      max-width: 90%;
      margin: 0 auto 1rem;
    }
    .controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      width: 100%;
      max-width: 600px;
      margin: 1rem 0;
    }
    canvas {
      border: 1px solid #ccc;
      max-width: 100%;
      height: auto;
      margin: 1rem 0;
    }
    .result {
      margin: 1rem auto;
      padding: 1rem;
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      text-align: left;
      width: 100%;
      max-width: 600px;
      font-size: clamp(0.9rem, 2.5vw, 1rem);
    }
    textarea {
      width: 100%;
      max-width: 600px;
      height: 100px;
      margin: 0.5rem 0;
      padding: 0.5rem;
      font-size: clamp(0.9rem, 2.5vw, 1rem);
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    input[type="file"],
    input[type="number"],
    input[type="color"] {
      width: 100%;
      max-width: 300px;
      padding: 0.5rem;
      font-size: clamp(0.9rem, 2.5vw, 1rem);
      margin: 0.25rem 0;
    }
    label {
      font-size: clamp(0.9rem, 2.5vw, 1rem);
      margin-right: 0.5rem;
    }
    button {
      padding: 0.75rem 1.5rem;
      font-size: clamp(0.9rem, 2.5vw, 1rem);
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      width: 100%;
      max-width: 200px;
    }
    button:hover {
      background-color: #0056b3;
    }
    a {
      display: inline-block;
      margin: 1rem 0;
      padding: 0.75rem 1.5rem;
      background-color: #007bff;
      color: white;
      text-decoration: none;
      border-radius: 5px;
      font-size: clamp(0.9rem, 2.5vw, 1rem);
    }
    a:hover {
      background-color: #0056b3;
    }
    #extractedText {
      white-space: pre-wrap;
      font-family: monospace;
      font-size: clamp(0.8rem, 2.5vw, 0.9rem);
    }
    #extractedTextContainer {
      display: none;
    }

    /* Media Queries for Mobile */
    @media (max-width: 600px) {
      body {
        padding: 3vw;
      }
      h1 {
        font-size: clamp(1.2rem, 4vw, 1.5rem);
      }
      p {
        font-size: clamp(0.8rem, 2.5vw, 0.9rem);
      }
      .controls {
        gap: 0.5rem;
      }
      input[type="file"],
      input[type="number"],
      input[type="color"] {
        max-width: 100%;
        padding: 0.4rem;
      }
      button {
        padding: 0.6rem 1rem;
        max-width: 150px;
      }
      canvas {
        max-width: 95%;
      }
      .result {
        padding: 0.75rem;
      }
      textarea {
        height: 80px;
      }
    }
  </style>
</head>
<body>
  <h1>Remove and Replace Text in Image</h1>
  <p>Upload an image to detect text using OCR, remove it, and optionally replace it with new text in the same locations.</p>
  <div class="controls">
    <label for="imageInput">Upload Image:</label>
    <input type="file" id="imageInput" accept="image/*">
    <label for="tolerance">Inpainting Tolerance:</label>
    <input type="number" id="tolerance" value="30" min="0" max="255">
    <label for="newText">New Text (one line per text region):</label>
    <textarea id="newText" placeholder="Enter new text (one line per detected text region)"></textarea>
    <label for="fontSize">Font Size (px):</label>
    <input type="number" id="fontSize" value="16" min="8" max="100">
    <label for="fontColor">Font Color:</label>
    <input type="color" id="fontColor" value="#000000">
    <button onclick="processImage()">Detect and Remove Text</button>
    <button onclick="applyNewText()" id="applyTextButton" style="display: none;">Apply New Text</button>
  </div>
  <div id="extractedTextContainer" class="result">
    <h3>Extracted Text:</h3>
    <div id="extractedText"></div>
  </div>
  <canvas id="originalCanvas"></canvas>
  <canvas id="processedCanvas"></canvas>
  <div id="downloadContainer"></div>

  <!-- Load Tesseract.js -->
  <script src="https://unpkg.com/tesseract.js@v4.1.1/dist/tesseract.min.js"></script>
  <script>
    let originalImageData = null;
    let processedImageData = null;
    let textRegions = [];
    let originalCanvas = null;
    let processedCanvas = null;

    // Detect text regions using OCR
    async function detectTextRegions(imageSrc) {
      try {
        const { data: { words } } = await Tesseract.recognize(imageSrc, 'eng', {
          logger: m => console.log(m)
        });
        
        textRegions = words.map(word => ({
          x: Math.max(0, word.bbox.x0 - 2),
          y: Math.max(0, word.bbox.y0 - 2),
          width: word.bbox.x1 - word.bbox.x0 + 4,
          height: word.bbox.y1 - word.bbox.y0 + 4,
          text: word.text
        }));
        
        console.log('Detected text regions:', textRegions);
        return textRegions;
      } catch (error) {
        console.error('OCR Error:', error);
        alert('OCR processing failed. Make sure the image contains readable text.');
        return [];
      }
    }

    // Inpaint text regions
    function inpaintTextRegions(imageData, textRegions, tolerance) {
      const data = imageData.data;
      const width = imageData.width;
      const height = imageData.height;
      
      const outputData = new Uint8ClampedArray(data.length);
      outputData.set(data);
      
      textRegions.forEach(region => {
        const { x, y, width: regWidth, height: regHeight } = region;
        
        for (let py = y; py < y + regHeight && py < height; py++) {
          for (let px = x; px < x + regWidth && px < width; px++) {
            const idx = (py * width + px) * 4;
            const r = data[idx];
            const g = data[idx + 1];
            const b = data[idx + 2];
            
            if (r + g + b < 3 * 100) { // Dark pixel heuristic
              const nearbyColor = getAverageNearbyColor(data, px, py, width, height, tolerance);
              outputData[idx] = nearbyColor.r;
              outputData[idx + 1] = nearbyColor.g;
              outputData[idx + 2] = nearbyColor.b;
              outputData[idx + 3] = 255;
            }
          }
        }
      });
      
      return new ImageData(outputData, width, height);
    }

    // Calculate average color of nearby non-dark pixels
    function getAverageNearbyColor(data, x, y, width, height, tolerance) {
      let rTotal = 0, gTotal = 0, bTotal = 0, count = 0;
      const radius = 5;
      
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          
          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            const nIdx = (ny * width + nx) * 4;
            const nr = data[nIdx];
            const ng = data[nIdx + 1];
            const nb = data[nIdx + 2];
            
            if (nr + ng + nb >= 3 * 100) {
              rTotal += nr;
              gTotal += ng;
              bTotal += nb;
              count++;
            }
          }
        }
      }
      
      return count > 0
        ? {
            r: Math.round(rTotal / count),
            g: Math.round(gTotal / count),
            b: Math.round(bTotal / count),
          }
        : { r: 255, g: 255, b: 255 };
    }

    // Apply new text to the processed image
    function applyNewText() {
      const newText = document.getElementById("newText").value.split('\n').filter(line => line.trim() !== '');
      const fontSize = parseInt(document.getElementById("fontSize").value);
      const fontColor = document.getElementById("fontColor").value;
      const ctx = processedCanvas.getContext("2d");
      
      // Start with the processed (text-removed) image
      ctx.putImageData(processedImageData, 0, 0);
      
      // Draw new text in detected regions
      ctx.font = `${fontSize}px Arial`;
      ctx.fillStyle = fontColor;
      ctx.textBaseline = "top";
      
      textRegions.forEach((region, index) => {
        if (index < newText.length) {
          ctx.fillText(newText[index], region.x, region.y);
        }
      });
      
      // Update download link
      const downloadContainer = document.getElementById("downloadContainer");
      downloadContainer.innerHTML = "";
      const downloadLink = document.createElement("a");
      downloadLink.href = processedCanvas.toDataURL("image/png");
      downloadLink.download = "text-replaced-image.png";
      downloadLink.textContent = "Download Image with New Text";
      downloadContainer.appendChild(downloadLink);
    }

    // Process the uploaded image
    async function processImage() {
      const imageInput = document.getElementById("imageInput");
      originalCanvas = document.getElementById("originalCanvas");
      processedCanvas = document.getElementById("processedCanvas");
      const tolerance = parseInt(document.getElementById("tolerance").value);

      if (imageInput.files.length === 0) {
        alert("Please upload an image.");
        return;
      }

      const img = new Image();
      img.onload = async function () {
        // Display original image
        originalCanvas.width = img.width;
        originalCanvas.height = img.height;
        const ctxOrig = originalCanvas.getContext("2d");
        ctxOrig.drawImage(img, 0, 0);
        
        // Get original image data
        originalImageData = ctxOrig.getImageData(0, 0, img.width, img.height);
        
        // Detect text regions
        const imageSrc = URL.createObjectURL(imageInput.files[0]);
        textRegions = await detectTextRegions(imageSrc);
        
        // Display extracted text
        if (textRegions.length > 0) {
          const extractedText = textRegions.map(region => region.text).join('\n');
          const extractedContainer = document.getElementById("extractedTextContainer");
          document.getElementById("extractedText").textContent = extractedText;
          extractedContainer.style.display = "block";
          document.getElementById("applyTextButton").style.display = "inline-block";
        } else {
          alert("No text detected. The image may not contain readable text.");
          return;
        }
        
        // Inpaint text regions
        processedImageData = inpaintTextRegions(originalImageData, textRegions, tolerance);
        
        // Display processed image
        processedCanvas.width = img.width;
        processedCanvas.height = img.height;
        const ctxProc = processedCanvas.getContext("2d");
        ctxProc.putImageData(processedImageData, 0, 0);
        
        // Create download link for text-removed image
        const downloadContainer = document.getElementById("downloadContainer");
        downloadContainer.innerHTML = "";
        const downloadLink = document.createElement("a");
        downloadLink.href = processedCanvas.toDataURL("image/png");
        downloadLink.download = "text-removed-ocr.png";
        downloadLink.textContent = "Download Text-Removed Image";
        downloadContainer.appendChild(downloadLink);
      };
      img.src = URL.createObjectURL(imageInput.files[0]);
    }
  </script>
</body>
</html>