<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Editor Chat</title>
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.js"></script>
</head>
<body>
    <script type="module">
        import React from 'https://esm.sh/react@18';
        import ReactDOM from 'https://esm.sh/react-dom@18';

        const { createFFmpeg, fetchFile } = FFmpeg;
        const ffmpeg = createFFmpeg({ log: true });
        let loaded = false;
        async function loadFFmpeg() {
            if (!loaded) {
                await ffmpeg.load();
                loaded = true;
            }
        }

        const systemPrompt = 'You are a helpful video editing assistant. Use the provided tools to apply filters and edits to the uploaded video. Respond with descriptions of actions and call tools when appropriate to perform the edits.';

        const tools = [
            {
                type: 'function',
                function: {
                    name: 'resize_video',
                    description: 'Resize the video to the specified width and height while maintaining aspect ratio if needed. This filter scales the video dimensions.',
                    parameters: {
                        type: 'object',
                        properties: {
                            width: { type: 'integer', description: 'The new width in pixels. Must be a positive even number for most codecs.' },
                            height: { type: 'integer', description: 'The new height in pixels. Must be a positive even number for most codecs. Use -1 to auto-scale based on width.' }
                        },
                        required: ['width', 'height']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'crop_video',
                    description: 'Crop a region of the video starting from the specified top-left corner with given width and height. Useful for removing borders or focusing on a part of the frame.',
                    parameters: {
                        type: 'object',
                        properties: {
                            x: { type: 'integer', description: 'The x-coordinate of the top-left corner of the crop area.' },
                            y: { type: 'integer', description: 'The y-coordinate of the top-left corner of the crop area.' },
                            width: { type: 'integer', description: 'The width of the crop area in pixels.' },
                            height: { type: 'integer', description: 'The height of the crop area in pixels.' }
                        },
                        required: ['x', 'y', 'width', 'height']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'rotate_video',
                    description: 'Rotate the video by the specified angle in degrees. Common for correcting orientation, e.g., 90 for clockwise, -90 for counter-clockwise.',
                    parameters: {
                        type: 'object',
                        properties: {
                            angle: { type: 'number', description: 'The rotation angle in degrees. Positive for clockwise, negative for counter-clockwise.' }
                        },
                        required: ['angle']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'add_text',
                    description: 'Overlay text on the video at a specified position with customizable size and color. Note: This assumes a default font is available in FFmpeg.',
                    parameters: {
                        type: 'object',
                        properties: {
                            text: { type: 'string', description: 'The text to overlay on the video.' },
                            x: { type: 'integer', description: 'The x-position for the text (default: 10).', default: 10 },
                            y: { type: 'integer', description: 'The y-position for the text (default: 10).', default: 10 },
                            fontsize: { type: 'integer', description: 'The font size (default: 24).', default: 24 },
                            color: { type: 'string', description: 'The font color (default: white).', default: 'white' }
                        },
                        required: ['text']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'trim_video',
                    description: 'Trim the video to keep only the portion between the start and end times. Times can be in seconds or HH:MM:SS format.',
                    parameters: {
                        type: 'object',
                        properties: {
                            start: { type: 'string', description: 'The start time (e.g., 00:00:10 or 10).' },
                            end: { type: 'string', description: 'The end time (e.g., 00:00:30 or 30).' }
                        },
                        required: ['start', 'end']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'adjust_speed',
                    description: 'Change the playback speed of the video and audio. A factor >1 speeds up, <1 slows down.',
                    parameters: {
                        type: 'object',
                        properties: {
                            speed: { type: 'number', description: 'The speed factor (e.g., 2 for double speed, 0.5 for half speed).' }
                        },
                        required: ['speed']
                    }
                }
            }
        ];

        const toolFunctions = {
            resize_video: async (args, videoFileData, setVideoFileData, addMessage) => {
                try {
                    // Validate inputs
                    if (!args.width || !args.height) {
                        throw new Error('Width and height are required');
                    }
                    if (args.width <= 0 || args.height <= 0) {
                        throw new Error('Width and height must be positive numbers');
                    }
                    
                    await loadFFmpeg();
                    ffmpeg.FS('writeFile', 'input.mp4', videoFileData);
                    await ffmpeg.run('-i', 'input.mp4', '-vf', `scale=${args.width}:${args.height}`, '-c:a', 'copy', 'output.mp4');
                    const data = ffmpeg.FS('readFile', 'output.mp4');
                    const newVideoData = new Uint8Array(data);
                    setVideoFileData(newVideoData);
                    const videoUrl = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));
                    addMessage('Processed video (resized):', false, videoUrl);
                    return 'Video resized successfully.';
                } catch (error) {
                    addMessage('Error resizing video: ' + error.message, false);
                    return 'Failed to resize video: ' + error.message;
                }
            },
            crop_video: async (args, videoFileData, setVideoFileData, addMessage) => {
                try {
                    // Validate inputs
                    if (args.x === undefined || args.y === undefined || !args.width || !args.height) {
                        throw new Error('x, y, width, and height are required for cropping');
                    }
                    if (args.x < 0 || args.y < 0 || args.width <= 0 || args.height <= 0) {
                        throw new Error('Crop dimensions must be valid positive numbers');
                    }
                    
                    await loadFFmpeg();
                    ffmpeg.FS('writeFile', 'input.mp4', videoFileData);
                    await ffmpeg.run('-i', 'input.mp4', '-vf', `crop=${args.width}:${args.height}:${args.x}:${args.y}`, '-c:a', 'copy', 'output.mp4');
                    const data = ffmpeg.FS('readFile', 'output.mp4');
                    const newVideoData = new Uint8Array(data);
                    setVideoFileData(newVideoData);
                    const videoUrl = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));
                    addMessage('Processed video (cropped):', false, videoUrl);
                    return 'Video cropped successfully.';
                } catch (error) {
                    addMessage('Error cropping video: ' + error.message, false);
                    return 'Failed to crop video: ' + error.message;
                }
            },
            rotate_video: async (args, videoFileData, setVideoFileData, addMessage) => {
                try {
                    await loadFFmpeg();
                    ffmpeg.FS('writeFile', 'input.mp4', videoFileData);
                    await ffmpeg.run('-i', 'input.mp4', '-vf', `rotate=${args.angle}*PI/180`, '-c:a', 'copy', 'output.mp4');
                    const data = ffmpeg.FS('readFile', 'output.mp4');
                    const newVideoData = new Uint8Array(data);
                    setVideoFileData(newVideoData);
                    const videoUrl = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));
                    addMessage('Processed video (rotated):', false, videoUrl);
                    return 'Video rotated successfully.';
                } catch (error) {
                    addMessage('Error rotating video: ' + error.message, false);
                    return 'Failed to rotate video: ' + error.message;
                }
            },
            add_text: async (args, videoFileData, setVideoFileData, addMessage) => {
                try {
                    await loadFFmpeg();
                    // Escape special characters in text to prevent injection
                    const escapedText = args.text.replace(/[\\:'"]/g, '\\$&').replace(/\n/g, '\\n');
                    ffmpeg.FS('writeFile', 'input.mp4', videoFileData);
                    await ffmpeg.run('-i', 'input.mp4', '-vf', `drawtext=text='${escapedText}':x=${args.x || 10}:y=${args.y || 10}:fontsize=${args.fontsize || 24}:fontcolor=${args.color || 'white'}`, '-c:a', 'copy', 'output.mp4');
                    const data = ffmpeg.FS('readFile', 'output.mp4');
                    const newVideoData = new Uint8Array(data);
                    setVideoFileData(newVideoData);
                    const videoUrl = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));
                    addMessage('Processed video (text added):', false, videoUrl);
                    return 'Text added to video successfully.';
                } catch (error) {
                    addMessage('Error adding text to video: ' + error.message, false);
                    return 'Failed to add text to video: ' + error.message;
                }
            },
            trim_video: async (args, videoFileData, setVideoFileData, addMessage) => {
                try {
                    // Validate inputs
                    if (!args.start || !args.end) {
                        throw new Error('Start and end times are required for trimming');
                    }
                    
                    await loadFFmpeg();
                    ffmpeg.FS('writeFile', 'input.mp4', videoFileData);
                    await ffmpeg.run('-i', 'input.mp4', '-ss', args.start, '-to', args.end, '-c', 'copy', 'output.mp4');
                    const data = ffmpeg.FS('readFile', 'output.mp4');
                    const newVideoData = new Uint8Array(data);
                    setVideoFileData(newVideoData);
                    const videoUrl = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));
                    addMessage('Processed video (trimmed):', false, videoUrl);
                    return 'Video trimmed successfully.';
                } catch (error) {
                    addMessage('Error trimming video: ' + error.message, false);
                    return 'Failed to trim video: ' + error.message;
                }
            },
            adjust_speed: async (args, videoFileData, setVideoFileData, addMessage) => {
                try {
                    // Validate inputs
                    if (!args.speed || args.speed <= 0) {
                        throw new Error('Speed must be a positive number');
                    }
                    
                    await loadFFmpeg();
                    ffmpeg.FS('writeFile', 'input.mp4', videoFileData);
                    
                    // atempo filter only supports values between 0.5 and 2.0
                    // For values outside this range, we need to chain multiple atempo filters
                    let audioFilter = '';
                    let speed = args.speed;
                    
                    if (speed >= 0.5 && speed <= 2.0) {
                        audioFilter = `atempo=${speed}`;
                    } else if (speed < 0.5) {
                        // Chain atempo filters for slow speeds
                        let remainingSpeed = speed;
                        const filters = [];
                        while (remainingSpeed < 0.5) {
                            filters.push('atempo=0.5');
                            remainingSpeed *= 2;
                        }
                        if (remainingSpeed !== 1.0) {
                            filters.push(`atempo=${remainingSpeed}`);
                        }
                        audioFilter = filters.join(',');
                    } else {
                        // Chain atempo filters for fast speeds
                        let remainingSpeed = speed;
                        const filters = [];
                        while (remainingSpeed > 2.0) {
                            filters.push('atempo=2.0');
                            remainingSpeed /= 2;
                        }
                        if (remainingSpeed !== 1.0) {
                            filters.push(`atempo=${remainingSpeed}`);
                        }
                        audioFilter = filters.join(',');
                    }
                    
                    await ffmpeg.run('-i', 'input.mp4', '-filter:v', `setpts=PTS/${args.speed}`, '-filter:a', audioFilter, 'output.mp4');
                    const data = ffmpeg.FS('readFile', 'output.mp4');
                    const newVideoData = new Uint8Array(data);
                    setVideoFileData(newVideoData);
                    const videoUrl = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));
                    addMessage('Processed video (speed adjusted):', false, videoUrl);
                    return 'Video speed adjusted successfully.';
                } catch (error) {
                    addMessage('Error adjusting video speed: ' + error.message, false);
                    return 'Failed to adjust video speed: ' + error.message;
                }
            }
        };

        const App = () => {
            const [token, setToken] = React.useState(localStorage.getItem('xaiToken') || '');
            const [showTokenPrompt, setShowTokenPrompt] = React.useState(!localStorage.getItem('xaiToken'));
            const [tempToken, setTempToken] = React.useState('');
            const [messages, setMessages] = React.useState([{ role: 'system', content: systemPrompt }]);
            const [chatInput, setChatInput] = React.useState('');
            const [videoFileData, setVideoFileData] = React.useState(null);
            const [originalVideoUrl, setOriginalVideoUrl] = React.useState(null);
            const chatWindowRef = React.useRef(null);

            React.useEffect(() => {
                if (chatWindowRef.current) {
                    chatWindowRef.current.scrollTop = chatWindowRef.current.scrollHeight;
                }
            }, [messages]);

            const handleSetToken = () => {
                if (tempToken) {
                    setToken(tempToken);
                    localStorage.setItem('xaiToken', tempToken);
                    setShowTokenPrompt(false);
                }
            };

            const addMessage = (text, isUser = false, videoUrl = null) => {
                setMessages(prev => [...prev, { role: isUser ? 'user' : 'assistant', content: text, videoUrl }]);
            };

            const callAPI = async (currentMessages) => {
                try {
                    const response = await fetch('https://api.grok.x.ai/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({
                            model: 'grok-beta',
                            messages: currentMessages,
                            tools: tools,
                            tool_choice: 'auto'
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    if (!data.choices || !data.choices[0]) {
                        throw new Error('Invalid response format from API');
                    }
                    
                    const msg = data.choices[0].message;

                    if (msg.content) {
                        addMessage(msg.content, false);
                        currentMessages.push({ role: 'assistant', content: msg.content });
                    }

                    if (msg.tool_calls) {
                        currentMessages.push({ role: 'assistant', content: null, tool_calls: msg.tool_calls });
                        for (const call of msg.tool_calls) {
                            const funcName = call.function.name;
                            const args = JSON.parse(call.function.arguments);
                            const result = await toolFunctions[funcName](args, videoFileData, setVideoFileData, addMessage);
                            currentMessages.push({
                                role: 'tool',
                                tool_call_id: call.id,
                                name: funcName,
                                content: result
                            });
                        }
                        await callAPI(currentMessages);
                    }
                } catch (error) {
                    addMessage('Error communicating with xAI API: ' + error.message, false);
                }
            };

            const handleUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    addMessage('Uploading video...', true);
                    const data = await fetchFile(file);
                    setVideoFileData(data);
                    const url = URL.createObjectURL(file);
                    setOriginalVideoUrl(url);
                    addMessage('Original video uploaded:', false, url);
                    const newMessages = [...messages, { role: 'user', content: 'Video uploaded and ready for editing.' }];
                    setMessages(newMessages);
                    await callAPI(newMessages);
                } catch (error) {
                    addMessage('Error uploading video: ' + error.message, false);
                }
            };

            const handleSend = async () => {
                const text = chatInput.trim();
                if (!text || !videoFileData) {
                    if (!videoFileData) alert('Please upload a video first.');
                    return;
                }
                addMessage(text, true);
                setChatInput('');
                const newMessages = [...messages, { role: 'user', content: text }];
                setMessages(newMessages);
                await callAPI(newMessages);
            };

            return (
                <div style={{ fontFamily: 'Arial, sans-serif', margin: 0, padding: 0, display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '100vh', backgroundColor: '#f0f0f0' }}>
                    <main style={{ width: '100%', height: '100vh', backgroundColor: 'white', overflow: 'hidden', display: 'flex', flexDirection: 'column', position: 'relative' }}>
                        <div style={{ position: 'absolute', top: '10px', right: '10px', display: 'flex', alignItems: 'center', gap: '10px' }}>
                            <span style={{ color: token ? 'green' : 'red' }}>{token ? 'Token set' : 'No token'}</span>
                            <button onClick={() => setShowTokenPrompt(true)} style={{ padding: '8px 16px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Set xAI Token</button>
                        </div>
                        {showTokenPrompt && (
                            <div style={{ position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', backgroundColor: 'white', padding: '20px', borderRadius: '8px', boxShadow: '0 2px 10px rgba(0,0,0,0.1)' }}>
                                <input type="text" value={tempToken} onChange={(e) => setTempToken(e.target.value)} placeholder="Enter xAI API token" style={{ width: '100%', padding: '8px', marginBottom: '10px', border: '1px solid #ddd', borderRadius: '4px' }} />
                                <button onClick={handleSetToken} style={{ padding: '8px 16px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Save</button>
                            </div>
                        )}
                        <div ref={chatWindowRef} style={{ flex: 1, overflowY: 'auto', padding: '16px' }}>
                            {messages.slice(1).map((msg, index) => (
                                <div key={index} style={{ marginBottom: '12px', padding: '8px 12px', borderRadius: '8px', maxWidth: '80%', alignSelf: msg.role === 'user' ? 'flex-end' : 'flex-start', marginLeft: msg.role === 'user' ? 'auto' : 0, marginRight: msg.role === 'user' ? 0 : 'auto', backgroundColor: msg.role === 'user' ? '#007bff' : '#e9ecef', color: msg.role === 'user' ? 'white' : 'black' }}>
                                    <p>{msg.content}</p>
                                    {msg.videoUrl && <video src={msg.videoUrl} controls style={{ width: '100%', maxWidth: '300px', marginTop: '8px', borderRadius: '4px' }} />}
                                </div>
                            ))}
                        </div>
                        <div style={{ display: 'flex', flexDirection: 'column', padding: '16px', gap: '8px', borderTop: '1px solid #ddd' }}>
                            <input type="file" onChange={handleUpload} accept="video/*" style={{ width: '100%' }} />
                            <input type="text" value={chatInput} onChange={(e) => setChatInput(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && handleSend()} placeholder="Describe the video edit..." style={{ width: '100%', padding: '8px', border: '1px solid #ddd', borderRadius: '4px' }} />
                            <button onClick={handleSend} style={{ padding: '8px 16px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Send</button>
                        </div>
                        {originalVideoUrl && (
                            <div style={{ position: 'absolute', bottom: '100px', left: '10px', backgroundColor: 'rgba(255,255,255,0.8)', padding: '10px', borderRadius: '4px' }}>
                                <p>Original Video Preview:</p>
                                <video src={originalVideoUrl} controls style={{ width: '200px' }} />
                            </div>
                        )}
                    </main>
                </div>
            );
        };

        ReactDOM.render(<App />, document.body);
    </script>
</body>
</html>