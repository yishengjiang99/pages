<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Goertzel Piano Roll - Dominant Frequency Detection</title>
<style>
  body { 
    margin: 0; 
    overflow: hidden; 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none; 
    -webkit-user-select: none; 
    touch-action: manipulation; 
    background: #1a1a1a;
    color: #eee;
  }
  
  #controls { 
    display: flex; 
    flex-wrap: wrap; 
    gap: 12px; 
    padding: 12px; 
    background: #222; 
    align-items: center; 
    border-bottom: 1px solid #444;
  }
  
  button, input[type=range] { 
    font-size: 16px; 
    padding: 10px 16px; 
    border-radius: 6px; 
    border: none; 
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  button { 
    background: #4CAF50; 
    color: white; 
    font-weight: bold;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }
  
  button:hover {
    background: #3e8e41;
    transform: translateY(-2px);
  }
  
  button:active {
    transform: translateY(0);
  }
  
  button:disabled {
    background: #666;
    cursor: not-allowed;
    transform: none;
  }
  
  .control-group { 
    display: flex; 
    flex-direction: column; 
    align-items: flex-start; 
    padding: 8px;
    background: #2a2a2a;
    border-radius: 8px;
    min-width: 160px;
  }
  
  .control-group label {
    font-size: 14px;
    margin-bottom: 6px;
    color: #ccc;
  }
  
  #volume { 
    width: 150px; 
    height: 20px; 
    background: #555; 
    position: relative; 
    border-radius: 3px;
    overflow: hidden;
  }
  
  #volumeLevel { 
    height: 100%; 
    width: 0%; 
    background: linear-gradient(to right, #4CAF50, #8BC34A, #CDDC39, #FFEB3B, #FFC107, #FF9800, #FF5722);
    transition: width 0.1s ease;
  }
  
  #volumeText { 
    font-size: 12px; 
    color: #fff; 
    margin-top: 4px; 
    text-align: center;
  }
  
  #noiseGateSlider { 
    width: 150px; 
    accent-color: #4CAF50;
  }
  
  #sensitivitySlider { 
    width: 150px; 
    accent-color: #2196F3;
  }
  
  #pianoContainer { 
    display: flex; 
    height: 600px; 
    overflow: hidden; 
  }
  
  #pianoAxis { 
    width: 60px; 
    background: #2a2a2a; 
    border-right: 1px solid #444; 
  }
  
  #pianoAxis svg { 
    width: 60px; 
    height: 100%; 
    display: block; 
  }
  
  #pianoRollWrapper { 
    flex: 1; 
    overflow-x: scroll; 
    overflow-y: hidden; 
    background: #111; 
    position: relative;
  }
  
  #pianoRoll { 
    height: 600px; 
  }
  
  #timeIndicator {
    position: absolute;
    top: 0;
    width: 2px;
    background: #f00;
    height: 100%;
    pointer-events: none;
    z-index: 10;
  }
  
  #log { 
    height: 120px; 
    overflow-y: scroll; 
    background: #000; 
    color: #0f0; 
    padding: 8px; 
    font-family: monospace;
    font-size: 12px; 
    white-space: pre-wrap; 
    border-top: 1px solid #444;
  }
  
  .status {
    padding: 8px 12px;
    border-radius: 20px;
    background: #333;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #f00;
  }
  
  .status-dot.recording {
    background: #f00;
    animation: pulse 1s infinite;
  }
  
  .status-dot.ready {
    background: #4CAF50;
  }
  
  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.4; }
    100% { opacity: 1; }
  }
  
  .title {
    font-size: 18px;
    font-weight: bold;
    margin-right: 10px;
    color: #4CAF50;
  }
</style>
</head>
<body>
<div id="controls">
  <span class="title">Piano Note Detector</span>
  <button id="startBtn">Start</button>
  <button id="stopBtn" disabled>Stop</button>
  <button id="exportBtn">Export MIDI</button>
  <button id="clearBtn">Clear</button>

  <div class="control-group">
    <label>Volume Level</label>
    <div id="volume"><div id="volumeLevel"></div></div>
    <div id="volumeText">0.00</div>
  </div>

  <div class="control-group">
    <label for="noiseGateSlider">Noise Gate Threshold</label>
    <input type="range" id="noiseGateSlider" min="0" max="0.1" step="0.001" value="0.02">
    <div id="noiseGateValue">0.02</div>
  </div>
  
  <div class="control-group">
    <label for="sensitivitySlider">Detection Sensitivity</label>
    <input type="range" id="sensitivitySlider" min="0.001" max="0.1" step="0.001" value="0.01">
    <div id="sensitivityValue">0.01</div>
  </div>
  
  <div class="status">
    <div id="statusDot" class="status-dot"></div>
    <span id="statusText">Ready</span>
  </div>
</div>

<div id="pianoContainer">
  <div id="pianoAxis">
    <svg id="axisSvg" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>
  <div id="pianoRollWrapper">
    <div id="timeIndicator"></div>
    <svg id="pianoRoll" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>
</div>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const volumeLevel = document.getElementById("volumeLevel");
const volumeText = document.getElementById("volumeText");
const noiseGateSlider = document.getElementById("noiseGateSlider");
const noiseGateValue = document.getElementById("noiseGateValue");
const sensitivitySlider = document.getElementById("sensitivitySlider");
const sensitivityValue = document.getElementById("sensitivityValue");
const startBtn = document.getElementById("startBtn");
const stopBtn = document.getElementById("stopBtn");
const clearBtn = document.getElementById("clearBtn");
const statusDot = document.getElementById("statusDot");
const statusText = document.getElementById("statusText");
const timeIndicator = document.getElementById("timeIndicator");

function log(msg) { 
  const timestamp = new Date().toLocaleTimeString();
  logEl.textContent += `[${timestamp}] ${msg}\n`; 
  logEl.scrollTop = logEl.scrollHeight; 
}

function updateStatus(status, isRecording = false) {
  statusText.textContent = status;
  statusDot.className = isRecording ? "status-dot recording" : "status-dot ready";
}

window.addEventListener("error", e => log("JS Error: " + e.message + " @ " + e.filename + ":" + e.lineno));
window.addEventListener("unhandledrejection", e => log("Unhandled Promise Rejection: " + e.reason));

let audioContext, mic, analyser, highpass, workletNode;
let running = false;
let capturedNotes = [];
let noteState = new Map();
let startTime = 0;
let currentTimePosition = 0;
const roll = document.getElementById("pianoRoll");

const minMidi = 40, maxMidi = 84;
const keyHeight = 12;
const widthPerSec = 100;
let noiseThreshold = parseFloat(noiseGateSlider.value);
let sensitivity = parseFloat(sensitivitySlider.value);
let animationFrame;

noiseGateSlider.oninput = () => {
  noiseThreshold = parseFloat(noiseGateSlider.value);
  noiseGateValue.textContent = noiseThreshold.toFixed(3);
  if(workletNode) workletNode.port.postMessage({type:"threshold",value:noiseThreshold});
};

sensitivitySlider.oninput = () => {
  sensitivity = parseFloat(sensitivitySlider.value);
  sensitivityValue.textContent = sensitivity.toFixed(3);
  if(workletNode) workletNode.port.postMessage({type:"sensitivity",value:sensitivity});
};

function drawAxis(){
  const NS = "http://www.w3.org/2000/svg";
  const axisSvg = document.getElementById("axisSvg");
  axisSvg.innerHTML = "";
  axisSvg.setAttribute("height",(maxMidi-minMidi+1)*keyHeight);
  
  for(let m = maxMidi; m >= minMidi; m--){
    const y = (maxMidi - m) * keyHeight;
    const rect = document.createElementNS(NS, "rect");
    rect.setAttribute("x", 0); 
    rect.setAttribute("y", y);
    rect.setAttribute("width", 60); 
    rect.setAttribute("height", keyHeight);
    rect.setAttribute("fill", [1,3,6,8,10].includes(m % 12) ? "#333" : "#2a2a2a");
    rect.setAttribute("stroke", "#444");
    axisSvg.appendChild(rect);
    
    if(![1,3,6,8,10].includes(m % 12)){
      const text = document.createElementNS(NS, "text");
      text.setAttribute("x", 5); 
      text.setAttribute("y", y + keyHeight - 2);
      text.setAttribute("font-size", "10");
      text.setAttribute("fill", "#eee");
      text.textContent = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][m % 12] + Math.floor(m / 12);
      axisSvg.appendChild(text);
    }
  }
}

function drawPianoRoll(){
  roll.innerHTML = "";
  const NS = "http://www.w3.org/2000/svg";
  const totalW = Math.max(6000, window.innerWidth - 60);
  const totalH = (maxMidi - minMidi + 1) * keyHeight;
  roll.setAttribute("width", totalW);
  roll.setAttribute("height", totalH);

  // Draw grid lines
  for (let i = 0; i < totalW / widthPerSec; i++) {
    const line = document.createElementNS(NS, "line");
    line.setAttribute("x1", i * widthPerSec);
    line.setAttribute("y1", 0);
    line.setAttribute("x2", i * widthPerSec);
    line.setAttribute("y2", totalH);
    line.setAttribute("stroke", i % 4 === 0 ? "#444" : "#333");
    line.setAttribute("stroke-width", i % 4 === 0 ? "1" : "0.5");
    roll.appendChild(line);
  }

  let notes = [...capturedNotes];
  if(running) { 
    for(let [m, st] of noteState) { 
      notes.push({midi: m, start: st.start, end: audioContext.currentTime}); 
    } 
  }

  for(let ev of notes){
    if(!ev.end || ev.end <= ev.start) continue;
    const x = ev.start * widthPerSec;
    const w = (ev.end - ev.start) * widthPerSec;
    const y = (maxMidi - ev.midi) * keyHeight;
    const rect = document.createElementNS(NS, "rect");
    rect.setAttribute("x", x);
    rect.setAttribute("y", y);
    rect.setAttribute("width", w);
    rect.setAttribute("height", keyHeight - 1);
    
    // Color based on note velocity (duration in this case)
    const hue = (ev.midi % 12) * 30;
    const saturation = 80;
    const lightness = 40 + Math.min(30, (w / widthPerSec) * 10);
    rect.setAttribute("fill", `hsl(${hue}, ${saturation}%, ${lightness}%)`);
    rect.setAttribute("rx", "2");
    rect.setAttribute("ry", "2");
    roll.appendChild(rect);
    
    // Add note label
    if (w > 30) {
      const text = document.createElementNS(NS, "text");
      text.setAttribute("x", x + 5);
      text.setAttribute("y", y + keyHeight/2 + 3);
      text.setAttribute("font-size", "10");
      text.setAttribute("fill", "#fff");
      text.textContent = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][ev.midi % 12] + Math.floor(ev.midi / 12);
      roll.appendChild(text);
    }
  }
  
  // Update time indicator position
  if (running) {
    currentTimePosition = (audioContext.currentTime - startTime) * widthPerSec;
    timeIndicator.style.left = currentTimePosition + 'px';
    
    // Auto-scroll to keep current time in view
    const wrapper = document.getElementById('pianoRollWrapper');
    if (currentTimePosition > wrapper.scrollLeft + wrapper.clientWidth - 100) {
      wrapper.scrollLeft = currentTimePosition - wrapper.clientWidth + 100;
    }
  }
}

async function setup(){
  const workletCode = `
    let threshold = ${noiseThreshold};
    let sensitivity = ${sensitivity};
    const notesFreqs = [];
    for(let m = 40; m <= 84; m++) { 
      notesFreqs[m] = 440 * Math.pow(2, (m - 69) / 12); 
    }
    
    // Precompute window function and coefficients for better performance
    const N = 1024;
    const hannWindow = new Float32Array(N);
    const coefficients = new Float32Array(85); // 40 to 84 inclusive
    
    for (let j = 0; j < N; j++) {
      hannWindow[j] = 0.5 * (1 - Math.cos(2 * Math.PI * j / (N - 1)));
    }
    
    for (let m = 40; m <= 84; m++) {
      coefficients[m] = 2 * Math.cos(2 * Math.PI * notesFreqs[m] / sampleRate * N);
    }
    
    class GoertzelProcessor extends AudioWorkletProcessor {
      constructor() {
        super();
        this.buf = new Float32Array(N);
        this.i = 0;
        this.hpBuf = 0;
        this.alpha = 2 * Math.PI * 70 / sampleRate;
        this.lastNoteTime = 0;
        this.currentNote = null;
        this.noteStartTime = 0;
        this.port.postMessage({type: "ready"});
        this.port.onmessage = e => { 
          if (e.data.type === "threshold") threshold = e.data.value; 
          if (e.data.type === "sensitivity") sensitivity = e.data.value; 
        };
      }
      
      process(inputs) { 
        let input = inputs[0]; 
        if (!input || !input[0]) return true; 
        
        let ch = input[0]; 
        for (let s of ch) { 
          this.hpBuf += this.alpha * (s - this.hpBuf);
          let x = this.hpBuf; 
          
          if (Math.abs(x) > threshold) { 
            this.buf[this.i++] = x;
            
            if (this.i >= N) {
              let maxPower = 0;
              let detectedNote = null;
              
              for (let m = 40; m <= 84; m++) {
                let coeff = coefficients[m];
                let s1 = 0, s2 = 0;
                
                for (let j = 0; j < N; j++) {
                  let win = this.buf[j] * hannWindow[j];
                  let s0 = win + coeff * s1 - s2;
                  s2 = s1;
                  s1 = s0;
                }
                
                let power = s1 * s1 + s2 * s2 - coeff * s1 * s2;
                if (power > maxPower) {
                  maxPower = power;
                  detectedNote = m;
                }
              }
              
              // Only report if power exceeds sensitivity and it's the dominant frequency
              if (maxPower > sensitivity) {
                const currentTime = currentTime;
                
                // If this is a new note or the same note after a gap
                if (this.currentNote !== detectedNote || (currentTime - this.lastNoteTime) > 0.1) {
                  // If we were tracking a previous note, send note off
                  if (this.currentNote !== null) {
                    this.port.postMessage({
                      type: "noteOff", 
                      note: this.currentNote, 
                      time: this.noteStartTime,
                      endTime: this.lastNoteTime
                    });
                  }
                  
                  // Start tracking new note
                  this.currentNote = detectedNote;
                  this.noteStartTime = currentTime;
                  this.port.postMessage({
                    type: "noteOn", 
                    note: detectedNote, 
                    time: currentTime
                  });
                }
                
                this.lastNoteTime = currentTime;
              } else if (this.currentNote !== null && (currentTime - this.lastNoteTime) > 0.1) {
                // If no note detected and we've passed the timeout, send note off
                this.port.postMessage({
                  type: "noteOff", 
                  note: this.currentNote, 
                  time: this.noteStartTime,
                  endTime: this.lastNoteTime
                });
                this.currentNote = null;
              }
              
              this.i = 0;
            }
          } else if (this.currentNote !== null && (currentTime - this.lastNoteTime) > 0.1) {
            // If signal is below threshold and we've passed the timeout, send note off
            this.port.postMessage({
              type: "noteOff", 
              note: this.currentNote, 
              time: this.noteStartTime,
              endTime: this.lastNoteTime
            });
            this.currentNote = null;
          }
        }
        
        return true;
      }
    }
    
    registerProcessor("goertzel-processor", GoertzelProcessor);
  `;
  
  try {
    const blob = new Blob([workletCode], { type: 'text/javascript' });
    const moduleURL = URL.createObjectURL(blob);
    await audioContext.audioWorklet.addModule(moduleURL);
    URL.revokeObjectURL(moduleURL);

    mic = await navigator.mediaDevices.getUserMedia({ audio: true });
    highpass = audioContext.createBiquadFilter();
    highpass.type = "highpass";
    highpass.frequency.value = 70;
    
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    
    workletNode = new AudioWorkletNode(audioContext, "goertzel-processor");
    const source = audioContext.createMediaStreamSource(mic);
    source.connect(highpass).connect(workletNode).connect(analyser);

    workletNode.port.onmessage = e => {
      let msg = e.data;
      if (msg.type === "ready") {
        log("Audio processing worklet ready");
        updateStatus("Ready to start");
      }
      if (msg.type === "noteOn" && running) {
        handleNoteOn(msg.note, msg.time);
      }
      if (msg.type === "noteOff" && running) {
        handleNoteOff(msg.note, msg.time, msg.endTime);
      }
    };

    visualizeVolume();
    return true;
  } catch (error) {
    log("Error setting up audio: " + error.message);
    updateStatus("Setup failed");
    return false;
  }
}

function visualizeVolume(){
  if (!analyser) return;
  
  const data = new Uint8Array(analyser.fftSize);
  
  function draw(){
    if (!analyser) return;
    
    requestAnimationFrame(draw);
    analyser.getByteTimeDomainData(data);
    
    let sum = 0;
    for (let v of data) {
      let d = v - 128;
      sum += d * d;
    }
    
    let rms = Math.sqrt(sum / data.length) / 128;
    volumeLevel.style.width = (rms * 100) + "%";
    volumeText.textContent = rms.toFixed(2);
  }
  
  draw();
}

function handleNoteOn(note, time) {
  if (!noteState.has(note)) { 
    noteState.set(note, { start: time }); 
    log("NoteOn " + note + " (" + ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][note % 12] + Math.floor(note / 12) + ")"); 
  }
}

function handleNoteOff(note, startTime, endTime) {
  if (noteState.has(note)) { 
    capturedNotes.push({ midi: note, start: startTime, end: endTime }); 
    noteState.delete(note); 
    log("NoteOff " + note + " (" + ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][note % 12] + Math.floor(note / 12) + ")"); 
    drawPianoRoll();
  }
}

startBtn.onclick = async () => {
  try {
    if (!audioContext) {
      audioContext = new AudioContext();
      updateStatus("Setting up audio...");
      
      const success = await setup();
      if (!success) return;
    }
    
    if (audioContext.state === "suspended") {
      await audioContext.resume();
    }
    
    running = true; 
    startTime = audioContext.currentTime; 
    startBtn.disabled = true;
    stopBtn.disabled = false;
    
    log("Recording started");
    updateStatus("Recording", true);
    
    // Animation loop for UI updates
    function updateUI() {
      if (running) {
        drawPianoRoll();
        animationFrame = requestAnimationFrame(updateUI);
      }
    }
    
    animationFrame = requestAnimationFrame(updateUI);
  } catch (e) { 
    log("StartBtn Error: " + e.message); 
    updateStatus("Error starting");
  }
};

stopBtn.onclick = () => {
  try { 
    if (audioContext && audioContext.state === "running") {
      audioContext.suspend(); 
    }
    
    running = false; 
    startBtn.disabled = false;
    stopBtn.disabled = true;
    
    log("Recording stopped");
    updateStatus("Stopped");
    
    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
    }
    
    drawPianoRoll();
  } catch (e) { 
    log("StopBtn Error: " + e.message); 
    updateStatus("Error stopping");
  }
};

clearBtn.onclick = () => {
  capturedNotes = [];
  noteState.clear();
  drawPianoRoll();
  log("Cleared all notes");
};

document.getElementById("exportBtn").onclick = () => { 
  try { 
    exportMIDI(); 
  } catch (e) { 
    log("ExportBtn Error: " + e.message); 
  } 
};

function exportMIDI() { 
  if (capturedNotes.length === 0 && noteState.size === 0) {
    log("No notes to export");
    return;
  }
  
  // Simple implementation for MIDI export
  let midiData = "MIDI data would be generated here\n";
  midiData += "Format: 1\n";
  midiData += "Tracks: 1\n";
  midiData += "Time division: 480\n";
  midiData += "Notes: " + (capturedNotes.length + noteState.size) + "\n\n";
  
  for (let note of capturedNotes) {
    midiData += `Note: ${note.midi}, Start: ${note.start.toFixed(2)}, End: ${note.end.toFixed(2)}\n`;
  }
  
  for (let [m, st] of noteState) {
    midiData += `Note: ${m}, Start: ${st.start.toFixed(2)}, End: (ongoing)\n`;
  }
  
  // Create download link
  const blob = new Blob([midiData], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'piano-roll.mid';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  log("MIDI data exported (simulated)");
};

// Initialize the application
drawAxis();
drawPianoRoll();
updateStatus("Ready");

// Handle window resize
window.addEventListener('resize', () => {
  drawPianoRoll();
});
</script>
</body>
</html>