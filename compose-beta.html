<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Goertzel Piano Roll with Hann Window</title>
<style>
  body { 
    margin: 0; 
    overflow: hidden; 
    font-family: sans-serif; 
    user-select: none; 
    -webkit-user-select: none; 
    touch-action: manipulation; 
    background: #1a1a1a;
    color: #eee;
  }
  
  #controls { 
    display: flex; 
    flex-wrap: wrap; 
    gap: 12px; 
    padding: 12px; 
    background: #222; 
    align-items: center; 
    border-bottom: 1px solid #444;
  }
  
  button, input[type=range] { 
    font-size: 16px; 
    padding: 10px 16px; 
    border-radius: 6px; 
    border: none; 
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  button { 
    background: #4CAF50; 
    color: white; 
    font-weight: bold;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }
  
  button:hover {
    background: #3e8e41;
    transform: translateY(-2px);
  }
  
  button:active {
    transform: translateY(0);
  }
  
  button:disabled {
    background: #666;
    cursor: not-allowed;
    transform: none;
  }
  
  .control-group { 
    display: flex; 
    flex-direction: column; 
    align-items: flex-start; 
    padding: 8px;
    background: #2a2a2a;
    border-radius: 8px;
    min-width: 160px;
  }
  
  .control-group label {
    font-size: 14px;
    margin-bottom: 6px;
    color: #ccc;
  }
  
  #volume { 
    width: 150px; 
    height: 20px; 
    background: #555; 
    position: relative; 
    border-radius: 3px;
    overflow: hidden;
  }
  
  #volumeLevel { 
    height: 100%; 
    width: 0%; 
    background: linear-gradient(to right, #4CAF50, #8BC34A, #CDDC39, #FFEB3B, #FFC107, #FF9800, #FF5722);
    transition: width 0.1s ease;
  }
  
  #volumeText { 
    font-size: 12px; 
    color: #fff; 
    margin-top: 4px; 
    text-align: center;
  }
  
  #noiseGateSlider { 
    width: 150px; 
    accent-color: #4CAF50;
  }
  
  #pianoContainer { 
    display: flex; 
    height: 600px; 
    overflow: hidden; 
  }
  
  #pianoAxis { 
    width: 60px; 
    background: #2a2a2a; 
    border-right: 1px solid #444; 
  }
  
  #pianoAxis svg { 
    width: 60px; 
    height: 100%; 
    display: block; 
  }
  
  #pianoRollWrapper { 
    flex: 1; 
    overflow-x: scroll; 
    overflow-y: hidden; 
    background: #111; 
    position: relative;
  }
  
  #pianoRoll { 
    height: 600px; 
  }
  
  #timeIndicator {
    position: absolute;
    top: 0;
    width: 2px;
    background: #f00;
    height: 100%;
    pointer-events: none;
    z-index: 10;
  }
  
  #log { 
    height: 120px; 
    overflow-y: scroll; 
    background: #000; 
    color: #0f0; 
    padding: 8px; 
    font-family: monospace;
    font-size: 12px; 
    white-space: pre-wrap; 
    border-top: 1px solid #444;
  }
  
  .status {
    padding: 8px 12px;
    border-radius: 20px;
    background: #333;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #f00;
  }
  
  .status-dot.recording {
    background: #f00;
    animation: pulse 1s infinite;
  }
  
  .status-dot.ready {
    background: #4CAF50;
  }
  
  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.4; }
    100% { opacity: 1; }
  }
</style>
</head>
<body>
<div id="controls">
  <button id="startBtn">Start</button>
  <button id="stopBtn" disabled>Stop</button>
  <button id="exportBtn">Export MIDI</button>

  <div class="control-group">
    <label>Volume Level</label>
    <div id="volume"><div id="volumeLevel"></div></div>
    <div id="volumeText">0.00</div>
  </div>

  <div class="control-group">
    <label for="noiseGateSlider">Noise Gate Threshold (dBFS)</label>
    <input type="range" id="noiseGateSlider" min="-100" max="-20" step="1" value="-60">
    <div id="noiseGateValue">-60</div>
  </div>
  
  <div class="status">
    <div id="statusDot" class="status-dot"></div>
    <span id="statusText">Ready</span>
  </div>
</div>

<div id="pianoContainer">
  <div id="pianoAxis">
    <svg id="axisSvg" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>
  <div id="pianoRollWrapper">
    <div id="timeIndicator"></div>
    <svg id="pianoRoll" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>
</div>

<pre id="log"></pre>

<script>
const logEl = document.getElementById("log");
const volumeLevel = document.getElementById("volumeLevel");
const volumeText = document.getElementById("volumeText");
const noiseGateSlider = document.getElementById("noiseGateSlider");
const noiseGateValue = document.getElementById("noiseGateValue");
const startBtn = document.getElementById("startBtn");
const stopBtn = document.getElementById("stopBtn");
const statusDot = document.getElementById("statusDot");
const statusText = document.getElementById("statusText");
const timeIndicator = document.getElementById("timeIndicator");

function log(msg) { 
  const timestamp = new Date().toLocaleTimeString();
  logEl.textContent += `[${timestamp}] ${msg}\n`; 
  logEl.scrollTop = logEl.scrollHeight; 
}

function updateStatus(status, isRecording = false) {
  statusText.textContent = status;
  statusDot.className = isRecording ? "status-dot recording" : "status-dot ready";
}

window.addEventListener("error", e => log("JS Error: " + e.message + " @ " + e.filename + ":" + e.lineno));
window.addEventListener("unhandledrejection", e => log("Unhandled Promise Rejection: " + e.reason));

let audioContext, mic, noiseGateNode, workletNode, rmsNode;
let running = false;
let capturedNotes = [];
let noteState = new Map();
let startTime = 0;
let currentTimePosition = 0;
const roll = document.getElementById("pianoRoll");

const minMidi = 40, maxMidi = 84;
const keyHeight = 12;
const widthPerSec = 100;
let noiseThreshold = parseFloat(noiseGateSlider.value);
let animationFrame;

noiseGateSlider.oninput = () => {
  noiseThreshold = parseFloat(noiseGateSlider.value);
  noiseGateValue.textContent = noiseThreshold.toFixed(0);
  if(noiseGateNode) {
    noiseGateNode.port.postMessage({ type: "threshold", value: noiseThreshold });
  }
};

function drawAxis(){
  const NS = "http://www.w3.org/2000/svg";
  const axisSvg = document.getElementById("axisSvg");
  axisSvg.innerHTML = "";
  axisSvg.setAttribute("height",(maxMidi-minMidi+1)*keyHeight);
  
  for(let m = maxMidi; m >= minMidi; m--){
    const y = (maxMidi - m) * keyHeight;
    const rect = document.createElementNS(NS, "rect");
    rect.setAttribute("x", 0); 
    rect.setAttribute("y", y);
    rect.setAttribute("width", 60); 
    rect.setAttribute("height", keyHeight);
    rect.setAttribute("fill", [1,3,6,8,10].includes(m % 12) ? "#333" : "#2a2a2a");
    rect.setAttribute("stroke", "#444");
    axisSvg.appendChild(rect);
    
    if(![1,3,6,8,10].includes(m % 12)){
      const text = document.createElementNS(NS, "text");
      text.setAttribute("x", 5); 
      text.setAttribute("y", y + keyHeight - 2);
      text.setAttribute("font-size", "10");
      text.setAttribute("fill", "#eee");
      text.textContent = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][m % 12] + Math.floor(m / 12);
      axisSvg.appendChild(text);
    }
  }
}

function drawPianoRoll(){
  const NS = "http://www.w3.org/2000/svg";
  let notes = [...capturedNotes];
  if(running) { 
    for(let [m, st] of noteState) { 
      notes.push({midi: m, start: st.start, end: audioContext.currentTime}); 
    } 
  }
  let maxTime = 0;
  for (let ev of notes) {
    const endRel = (ev.end || 0) - startTime;
    if (endRel > maxTime) maxTime = endRel;
  }
  const totalW = Math.max((maxTime + 5) * widthPerSec + 200, window.innerWidth - 60);
  const totalH = (maxMidi - minMidi + 1) * keyHeight;
  roll.setAttribute("width", totalW);
  roll.setAttribute("height", totalH);

  // Only clear notes, not grid lines
  const existingNotes = roll.querySelectorAll("rect.note, text.note-label");
  existingNotes.forEach(el => el.remove());

  // Add grid lines if needed
  const neededLines = Math.ceil(totalW / widthPerSec);
  const currentLines = roll.querySelectorAll("line.grid-line").length;
  if (neededLines > currentLines) {
    for (let i = currentLines; i < neededLines; i++) {
      const line = document.createElementNS(NS, "line");
      line.setAttribute("x1", i * widthPerSec);
      line.setAttribute("y1", 0);
      line.setAttribute("x2", i * widthPerSec);
      line.setAttribute("y2", totalH);
      line.setAttribute("stroke", i % 4 === 0 ? "#444" : "#333");
      line.setAttribute("stroke-width", i % 4 === 0 ? "1" : "0.5");
      line.classList.add("grid-line");
      roll.insertBefore(line, roll.firstChild);
    }
  }

  for(let ev of notes){
    if(!ev.end || ev.end <= ev.start) continue;
    const x = (ev.start - startTime) * widthPerSec;
    const w = (ev.end - ev.start) * widthPerSec;
    const y = (maxMidi - ev.midi) * keyHeight;
    const rect = document.createElementNS(NS, "rect");
    rect.setAttribute("x", x);
    rect.setAttribute("y", y);
    rect.setAttribute("width", w);
    rect.setAttribute("height", keyHeight - 1);
    rect.setAttribute("fill", "#4CAF50");
    rect.setAttribute("rx", "2");
    rect.setAttribute("ry", "2");
    rect.classList.add("note");
    roll.appendChild(rect);
    
    if (w > 30) {
      const text = document.createElementNS(NS, "text");
      text.setAttribute("x", x + 5);
      text.setAttribute("y", y + keyHeight/2 + 3);
      text.setAttribute("font-size", "10");
      text.setAttribute("fill", "#000");
      text.textContent = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][ev.midi % 12] + Math.floor(ev.midi / 12);
      text.classList.add("note-label");
      roll.appendChild(text);
    }
  }
  
  if (running) {
    currentTimePosition = (audioContext.currentTime - startTime) * widthPerSec;
    timeIndicator.style.left = currentTimePosition + 'px';
    
    const wrapper = document.getElementById('pianoRollWrapper');
    if (currentTimePosition > wrapper.scrollLeft + wrapper.clientWidth - 100) {
      wrapper.scrollLeft = currentTimePosition - wrapper.clientWidth + 100;
    }
  }
}

async function setup(){
  const workletCode = `
    const notesFreqs = [];
    for(let m = 40; m <= 84; m++) { 
      notesFreqs[m] = 440 * Math.pow(2, (m - 69) / 12); 
    }
    
    const N = 1024;
    const hannWindow = new Float32Array(N);
    const coefficients = new Float32Array(85);
    
    for (let j = 0; j < N; j++) {
      hannWindow[j] = 0.5 * (1 - Math.cos(2 * Math.PI * j / (N - 1)));
    }
    
    for (let m = 40; m <= 84; m++) {
      coefficients[m] = 2 * Math.cos(2 * Math.PI * notesFreqs[m] / sampleRate * N);
    }
    
    class GoertzelProcessor extends AudioWorkletProcessor {
      constructor() {
        super();
        this.buf = new Float32Array(N);
        this.i = 0;
        this.port.postMessage({type: "ready"});
        this.port.onmessage = e => { 
          if (e.data.type === "threshold") this.threshold = e.data.value; 
        };
        this.threshold = -60; // Initial threshold in dBFS
      }
      
      process(inputs) { 
        let input = inputs[0]; 
        if (!input || !input[0]) return true; 
        
        let ch = input[0]; 
        for (let s of ch) { 
          this.buf[this.i++] = s;
          
          if (this.i >= N) {
            let maxPower = 0;
            let maxMidi = -1;
            
            for (let m = 40; m <= 84; m++) {
              let coeff = coefficients[m];
              let s1 = 0, s2 = 0;
              
              for (let j = 0; j < N; j++) {
                let win = this.buf[j] * hannWindow[j];
                let s0 = win + coeff * s1 - s2;
                s2 = s1;
                s1 = s0;
              }
              
              let power = s1 * s1 + s2 * s2 - coeff * s1 * s2;
              if (power > maxPower && power > 0.05) {
                maxPower = power;
                maxMidi = m;
              }
            }
            
            if (maxMidi !== -1) {
              this.port.postMessage({type: "notes", notes: [maxMidi], time: currentTime});
            }
            
            this.i = 0;
          }
        }
        
        return true;
      }
    }

    class RMSProcessor extends AudioWorkletProcessor {
      constructor() {
        super();
        this.port.postMessage({type: "ready"});
      }
      
      process(inputs) { 
        let input = inputs[0]; 
        if (!input || !input[0]) return true; 
        
        let ch = input[0]; 
        let sum = 0;
        for (let s of ch) { 
          sum += s * s;
        }
        let rms = Math.sqrt(sum / ch.length);
        this.port.postMessage({type: "rms", value: rms});
        return true;
      }
    }

    class NoiseGateProcessor extends AudioWorkletProcessor {
      constructor() {
        super();
        this.threshold = -60;
        this.attack = 0.01;
        this.release = 0.05;
        this.prevGain = 1.0;
        this.port.onmessage = e => {
          if (e.data.type === "threshold") this.threshold = e.data.value;
          if (e.data.type === "attack") this.attack = e.data.value;
          if (e.data.type === "release") this.release = e.data.value;
        };
      }

      static toDecibel(power) {
        return 10 * Math.log10(power + 1e-12);
      }

      process(inputs, outputs) {
        const input = inputs[0];
        const output = outputs[0];
        if (!input || !input[0]) return true;

        const channel = input[0];
        const out = output[0];

        const sr = sampleRate;
        const attackCoeff = Math.exp(-1 / (sr * this.attack));
        const releaseCoeff = Math.exp(-1 / (sr * this.release));

        let gain = this.prevGain;

        for (let i = 0; i < channel.length; i++) {
          const level = NoiseGateProcessor.toDecibel(channel[i] * channel[i]);
          if (level < this.threshold) {
            gain = gain * attackCoeff;
          } else {
            gain = 1 - (1 - gain) * releaseCoeff;
          }
          out[i] = channel[i] * gain;
        }

        this.prevGain = gain;
        return true;
      }
    }

    registerProcessor("goertzel-processor", GoertzelProcessor);
    registerProcessor("rms-processor", RMSProcessor);
    registerProcessor("noise-gate-processor", NoiseGateProcessor);
  `;
  
  const blob = new Blob([workletCode], {type: "application/javascript"});
  const url = URL.createObjectURL(blob);
  audioContext = new AudioContext();
  await audioContext.audioWorklet.addModule(url);

  mic = await navigator.mediaDevices.getUserMedia({audio: true});
  const source = audioContext.createMediaStreamSource(mic);

  noiseGateNode = new AudioWorkletNode(audioContext, "noise-gate-processor");
  noiseGateNode.port.postMessage({ type: "threshold", value: noiseThreshold });
  noiseGateNode.port.postMessage({ type: "attack", value: 0.01 });
  noiseGateNode.port.postMessage({ type: "release", value: 0.05 });

  workletNode = new AudioWorkletNode(audioContext, "goertzel-processor");
  rmsNode = new AudioWorkletNode(audioContext, "rms-processor");

  source.connect(noiseGateNode);
  noiseGateNode.connect(workletNode);
  noiseGateNode.connect(rmsNode);

  workletNode.port.onmessage = e => { 
    if(e.data.type === "notes"){ 
      handleNotes(e.data.notes, e.data.time); 
    }
  };
  
  rmsNode.port.onmessage = e => { 
    if(e.data.type === "rms"){ 
      let rms = e.data.value; 
      let db = 20 * Math.log10(rms + 1e-12);
      let pct = Math.min(100, Math.max(0, (db + 100) / 80 * 100));
      volumeLevel.style.width = pct + "%"; 
      volumeText.textContent = db.toFixed(2); 
    } 
  };
}

function handleNotes(notes, time){
  for(let m of notes){
    if(!noteState.has(m)){ 
      noteState.set(m, {start: audioContext.currentTime}); 
      log("Note on " + m);
    }
  }
  
  for(let [m, st] of [...noteState]) {
    if(!notes.includes(m)) {
      capturedNotes.push({midi: m, start: st.start, end: audioContext.currentTime});
      noteState.delete(m);
      log("Note off " + m);
    }
  }
}

function start(){
  running = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  capturedNotes = [];
  noteState.clear();
  startTime = audioContext.currentTime;
  updateStatus("Recording", true);
  drawAxis();
  
  function loop(){
    drawPianoRoll();
    animationFrame = requestAnimationFrame(loop);
  }
  loop();
}

function stop(){
  running = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  for(let [m, st] of noteState) {
    capturedNotes.push({midi: m, start: st.start, end: audioContext.currentTime});
  }
  noteState.clear();
  cancelAnimationFrame(animationFrame);
  updateStatus("Stopped", false);
}

startBtn.onclick = async () => {
  try { 
    if(!audioContext){ await setup(); }
    start(); 
  } catch(e){ 
    log("Start error: " + e); 
  }
};
stopBtn.onclick = () => { try { stop(); } catch(e){ log("Stop error: " + e); } };

function exportMIDI(){
  const events = [];
  const push = arr => events.push(...arr);
  
  const notes = [...capturedNotes];
  push(notes.map(n => ({type:"on", time: Math.round((n.start - startTime) * 1000), midi: n.midi})));
  push(notes.map(n => ({type:"off", time: Math.round((n.end - startTime) * 1000), midi: n.midi})));
  
  events.sort((a,b)=>a.time-b.time);
  
  function encodeVLQ(val){
    const bytes=[]; let v=val;
    do{ let b=v&0x7F; v>>=7; if(bytes.length>0) b|=0x80; bytes.unshift(b);}while(v>0);
    return bytes;
  }
  
  const chunks=[];
  const pushBytes=(...bytes)=>chunks.push(...bytes);
  const textEncoder=new TextEncoder();
  
  chunks.push(...textEncoder.encode("MThd"));
  pushBytes(0,0,0,6, 0,0, 0,1, 0,96);
  
  const track=[];
  let lastTime=0;
  function writeEvent(time, data){
    const delta=time-lastTime;
    lastTime=time;
    track.push(...encodeVLQ(delta),...data);
  }
  
  events.forEach(ev=>{
    if(ev.type==="on") writeEvent(ev.time,[0x90, ev.midi, 100]);
    if(ev.type==="off") writeEvent(ev.time,[0x80, ev.midi, 64]);
  });
  writeEvent(events.length>0 ? events[events.length-1].time+200 : 0,[0xFF,0x2F,0x00]);
  
  const trackHeader=textEncoder.encode("MTrk");
  const trackLength=track.length;
  const lenBytes=[(trackLength>>>24)&0xFF,(trackLength>>>16)&0xFF,(trackLength>>>8)&0xFF,trackLength&0xFF];
  
  const midiFile=new Uint8Array([...chunks, ...trackHeader, ...lenBytes, ...track]);
  const blob=new Blob([midiFile],{type:"audio/midi"});
  const url=URL.createObjectURL(blob);
  
  const a=document.createElement("a");
  a.href=url;
  a.download="output.mid";
  a.click();
  URL.revokeObjectURL(url);
}

document.getElementById("exportBtn").onclick = () => { try { exportMIDI(); } catch(e){ log("Export error: " + e); } };

drawAxis();
updateStatus("Ready", false);
</script>
</body>
</html>