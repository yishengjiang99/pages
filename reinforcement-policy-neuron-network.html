<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cart-Pole + Neural Policy (CEM) — Mobile Friendly</title>
<style>
  :root{--bg:#0f1720;--panel:#0b1220;--muted:#9aa7b2;--accent:#50d890}
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{background:linear-gradient(180deg,#07101a,#07121b);color:#e6eef6;display:flex;gap:12px;padding:12px;box-sizing:border-box}
  .left{flex:1;display:flex;flex-direction:column;gap:12px}
  canvas{background:#071126;border-radius:8px;display:block;max-width:100%}
  .panel{background:rgba(10,18,28,0.9);padding:10px;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{background:#0b1520;border:1px solid rgba(255,255,255,0.04);color:#cfe;padding:8px 10px;border-radius:6px;cursor:pointer}
  button.active{background:var(--accent);color:#042118}
  label{color:var(--muted);font-size:13px;display:flex;gap:8px;align-items:center}
  input[type=range]{width:100%}
  .stat{font-size:13px;color:var(--muted)}
  .net-canvas{background:#041018;border-radius:8px;padding:8px;overflow:hidden}
  small{color:var(--muted)}

  /* Mobile responsive layout */
  @media (max-width: 800px) {
    body{flex-direction:column}
    .controls button{flex:1}
    .stat{font-size:12px}
  }
</style>
</head>
<body>

<div class="left">
  <div class="panel">
    <h3 style="margin:0">Cart-Pole + Policy (CEM)</h3>
    <canvas id="world" width="900" height="360" style="width:100%;height:auto"></canvas>
    <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">
      <div class="controls">
        <button id="startBtn">Start sim</button>
        <button id="resetBtn">Reset</button>
      </div>
    </div>
  </div>

  <!-- Network panel -->
  <div class="panel net-canvas">
    <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap">
      <div><strong>Policy Network</strong><br><small class="stat">inputs: x, xdot, θ, θdot (+bias)</small></div>
      <div style="text-align:right">
        <div class="stat">Hidden: <span id="hiddenCount">8</span></div>
      </div>
    </div>
    <canvas id="net" width="380" height="240" style="width:100%;height:auto;margin-top:8px"></canvas>
  </div>
</div>

<script>
/* -----------------------
   Cart-Pole Environment
-------------------------*/
class CartPole {
  constructor() {
    this.gravity = 9.8;
    this.massCart = 1.0;
    this.massPole = 0.1;
    this.totalMass = this.massCart + this.massPole;
    this.length = 0.5;
    this.polemassLength = this.massPole * this.length;
    this.forceMag = 10;
    this.tau = 0.02;
    this.reset();
  }
  reset() {
    this.state = [Math.random()*0.08-0.04, 0, Math.random()*0.08-0.04, 0];
    this.steps = 0;
    return this.state;
  }
  step(action) {
    let [x, xDot, theta, thetaDot] = this.state;
    let force = action===1 ? this.forceMag : -this.forceMag;
    let costheta = Math.cos(theta), sintheta = Math.sin(theta);
    let temp = (force + this.polemassLength*thetaDot*thetaDot*sintheta)/this.totalMass;
    let thetaAcc = (this.gravity*sintheta - costheta*temp) /
      (this.length*(4.0/3.0 - this.massPole*costheta*costheta/this.totalMass));
    let xAcc = temp - this.polemassLength*thetaAcc*costheta/this.totalMass;
    x += this.tau*xDot;
    xDot += this.tau*xAcc;
    theta += this.tau*thetaDot;
    thetaDot += this.tau*thetaAcc;
    this.state = [x,xDot,theta,thetaDot];
    this.steps++;
    let done = (x<-2.4||x>2.4||theta<-12*Math.PI/180||theta>12*Math.PI/180);
    return [this.state,1,done];
  }
}

/* -----------------------
   Simple Neural Policy
-------------------------*/
class Policy {
  constructor(inSize,hidSize) {
    this.inSize = inSize; this.hidSize = hidSize;
    this.weights1 = Array.from({length:hidSize},()=>Array.from({length:inSize},()=>Math.random()*0.2-0.1));
    this.weights2 = Array.from({length:hidSize},()=>Math.random()*0.2-0.1);
  }
  act(state) {
    let withBias = [...state, 1.0]; // add bias term
    let hidden = this.weights1.map(w=>tanh(dot(w,withBias)));
    let score = dot(this.weights2,hidden);
    return score>0?1:0;
  }
}
function dot(a,b){return a.reduce((s,v,i)=>s+v*b[i],0);}
function tanh(x){return Math.tanh(x);}

/* -----------------------
   Drawing
-------------------------*/
const worldCanvas=document.getElementById("world");
const ctxW=worldCanvas.getContext("2d");
const netCanvas=document.getElementById("net");
const ctxN=netCanvas.getContext("2d");

function drawWorld(env){
  ctxW.clearRect(0,0,worldCanvas.width,worldCanvas.height);
  ctxW.fillStyle="#fff";
  let scale=80;
  let [x,,theta]=env.state;
  let cartX=worldCanvas.width/2 + x*scale;
  let cartY=300;
  ctxW.fillRect(cartX-25,cartY-15,50,30);
  let poleX=cartX+ Math.sin(theta)*-150;
  let poleY=cartY- Math.cos(theta)*150;
  ctxW.strokeStyle="#f88"; ctxW.lineWidth=6;
  ctxW.beginPath(); ctxW.moveTo(cartX,cartY); ctxW.lineTo(poleX,poleY); ctxW.stroke();
}

function drawNetwork(policy){
  ctxN.clearRect(0,0,netCanvas.width,netCanvas.height);
  let small=window.innerWidth<800;
  let nodeR=small?7:10, hGap=small?70:90, vGap=small?26:36, fontSize=small?9:11;
  ctxN.font=fontSize+"px sans-serif"; ctxN.textAlign="center";
  // Input nodes
  let inputs=policy.inSize;
  for(let i=0;i<inputs;i++){
    ctxN.beginPath(); ctxN.arc(40,40+i*vGap,nodeR,0,Math.PI*2); ctxN.fillStyle="#88f"; ctxN.fill();
    ctxN.fillStyle="#fff"; ctxN.fillText("i"+i,40,40+i*vGap+nodeR+fontSize);
  }
  // Hidden
  for(let j=0;j<policy.hidSize;j++){
    ctxN.beginPath(); ctxN.arc(40+hGap,40+j*vGap,nodeR,0,Math.PI*2); ctxN.fillStyle="#8f8"; ctxN.fill();
  }
  // Output
  ctxN.beginPath(); ctxN.arc(40+2*hGap,100,nodeR,0,Math.PI*2); ctxN.fillStyle="#f88"; ctxN.fill();
  ctxN.fillStyle="#fff"; ctxN.fillText("out",40+2*hGap,100+nodeR+fontSize);
}

/* -----------------------
   Simulation Loop
-------------------------*/
let env=new CartPole();
let policy=new Policy(5,8); // 4 inputs + bias
drawWorld(env); drawNetwork(policy);

let running=false;
function step(){
  if(!running) return;
  let a=policy.act(env.state);
  let [_,__,done]=env.step(a);
  drawWorld(env); drawNetwork(policy);
  if(!done) requestAnimationFrame(step);
  else running=false;
}

document.getElementById("startBtn").onclick=()=>{
  if(!running){running=true; step();}
};
document.getElementById("resetBtn").onclick=()=>{
  env.reset(); drawWorld(env); drawNetwork(policy); running=false;
};
</script>
</body>
</html>